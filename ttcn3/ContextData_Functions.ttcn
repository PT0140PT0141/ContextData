/**
 * @author  PT28/PT0141 
 * @desc    This module provides functions used by Context Data TCs
 * @version $id$
 */
module ContextData_Functions {
    // EFC
    /**
     * @desc    [17575-1:2016]: Charging
     * @see     Annex A (normative) EFC data type specifications
     */
    import from EfcAutonomousCharging language "ASN.1:1997" all;
    /**
     * @desc    [17575-1:2016]: Context data
     * @see     A.2 Data specifications
     */
    import from EfcAutonomousContextData language "ASN.1:1997" all;
     
     // LibEfc_Common
    /**
     * @desc    TTCN-3 does not support ASN.1 parameterization (ETSI ES 201 873-7 V4.5.1 Clause 10)
     *          Common_Parameterised_Asn1_Data TTCN-3 module is a workaround
     */
    import from Common_Parameterised_Asn1_Data all;
    import from Common_Interfaces all;
    import from Common_Templates all;
    import from Common_Functions all;
    import from Common_LibUpperTester all;
    import from Common_Defaults all;
    import from Common_Pics all;
    
    // ContextData
    import from ContextData_TypesAndValues all;
    import from ContextData_Pixits all;

    /**
     * @desc    Preambule functions:
     * - Initialize communication stack
     * - Map TTCN-3 ports
     * - Activate needed defaults
     */
    group ContextData_Preamble {
        /**
         * @desc    Prepare preambule
         * @verdict unchanged
         */
        function f_contextData_Preambule() runs on EutComp {
            // Initialize communication stack
            f_InitializeCommunication();
            
            if (PICS_SECURED_MODE) {
                fx_initialiseSecurity();
            }
            
            // Map TTCN-3 ports to TestAdapter ports
            map(self:pco, system:ta_pco);
            map(self:eaPort, system:ta_eaPort);
            
            // Activate message filtering timeouts
            // See  
            activate(a_defaults());
            // Activate UpperTester
            activate(a_upperTester());
        } // End of function f_contextData_Preambule()
    } // End of group ContextData_Preamble

    /**
     * @desc    Postambule functions
     * - Deactivate all activated defaults
     * - Unmap TTCN-3 ports
     * - De-Initialize communication stack
     */
    group ContextData_Postamble {
        /**
         * @desc    Execute postambule
         * @verdict unchanged
         */
        function f_contextData_Postambule() runs on EutComp {
            // Deactivate all message filtering
            deactivate;
            
            // Unmap TTCN-3 ports to TestAdapter ports
            unmap(self:pco, system:ta_pco);
            unmap(self:eaPort, system:ta_eaPort);
            
            if (PICS_SECURED_MODE) {
                fx_uninitialiseSecurity();
            }
            
            // De-nitialize communication stack
            f_DeInitializeCommunication();
        } // End of function f_contextData_Preambule()
    } // End of group ContextData_Postamble

    /**
     * @desc    Validation functions group
     */
    group Validation {

        /**
         * @desc    This function checks that the type of Charge Unit is compliant to Toll Scheme Type
         * @param   p_tollcontextoverview TollContextOverview value
         * @param   p_tariffTables TariffTables value
         * @return  true on success, false otherwise
         */
        function f_check_compliancy_chargeUnit_tollContextPartitionType(
                                                                        in template (value) TollContextPartitionOverviews p_tollContextPartitionOverviews,
                                                                        in template (value) TariffTables p_tariffTables
        ) runs on EutComp return boolean {
            // p_tarifftable shall not be omit
            
            for (var integer v_idx := 0; v_idx < sizeof(p_tollContextPartitionOverviews); v_idx := v_idx + 1) {
                var TollContextPartitionOverview v_tollContextPartitionOverview := valueof(p_tollContextPartitionOverviews[v_idx]);
                
                for (var integer v_counter := 0; v_counter < sizeof(p_tariffTables); v_counter := v_counter + 1) {
                    var TariffTable v_tariffTable := p_tariffTables[v_counter];
                    
                    if (v_tollContextPartitionOverview.tollContextPartitionType  == TollSchemeType_roadSectionPricing_) {
                        // Parse Tariffs list
                        for (var integer v_jdx := 0; v_jdx < sizeof(v_tariffTable.tariffs); v_jdx := v_jdx + 1) {
                            if (ischosen(v_tariffTable.tariffs[v_jdx].chargeUnit.time)) {
                                return false; // Error
                            } // else continue
                        } // End of 'for' statement
                    } else if ((v_tollContextPartitionOverview.tollContextPartitionType == TollSchemeType_areaPricingDistance_) or (v_tollContextPartitionOverview.tollContextPartitionType == TollSchemeType_areaPricingTime_)){
                        // Parse Tariffs list
                        for (var integer v_jdx := 0; v_jdx < sizeof(v_tariffTable.tariffs); v_jdx := v_jdx + 1) {
                            if (ischosen(v_tariffTable.tariffs[v_jdx].chargeUnit.event)) {
                                return false; // Error
                            } // else continue
                        } // End of 'for' statement
                    } else if (v_tollContextPartitionOverview.tollContextPartitionType == TollSchemeType_cordonPricing_) {
                        // Parse Tariffs list
                        for (var integer v_jdx := 0; v_jdx < sizeof(v_tariffTable.tariffs); v_jdx := v_jdx + 1) {
                            if (not ischosen(v_tariffTable.tariffs[v_jdx].chargeUnit.event)) {
                                return false; // Error
                            } // else continue
                        } // End of 'for' statement
                    }
                } // End of 'for' statement
            } // End of 'for' statement
            
            return true;
        } // End of function f_check_compliancy_chargeUnit_tollContextPartitionType
        
        /**
         * @desc    This function verifies the uniqueness tariffClass of Tariff class list
         * @param   p_tariffTables Tariff table list
         * @return  true on success, false otherwise
         * @verdict unchanged
         */
        function f_check_uniqueness_tariffClassID(
                                                  in TariffTables p_tariffTables
        ) runs on EutComp return boolean {
            // p_tariffTable shall not be omit
            
            var charstring v_tariffClassIdFound := ";"; // Used to build the list of the tariffClassId already processed
            var charstring v_tariffClassId; // tariffClassId currently processed
            var template charstring m_found_pattern; // Used in regex to verify that 'tariffClassId' was not found before
            
            for (var integer v_counter := 0; v_counter < sizeof(p_tariffTables); v_counter := v_counter + 1) {
                var TariffTable v_tariffsList := p_tariffTables[v_counter];
                
                // Parse Tariffs list
                for (var integer v_idx := 0; v_idx < sizeof(v_tariffsList.tariffs); v_idx := v_idx + 1) {
                    v_tariffClassId := int2str(v_tariffsList.tariffs[v_idx].tariffClass);
                    m_found_pattern := pattern "*({v_tariffClassId})*";
                    if (regexp(v_tariffClassIdFound, m_found_pattern, 0) == v_tariffClassId) {
                        return false; // tariffClassId exist at least 2 times, uniqueness is not verified
                    }
                    // tariffClassId non found, add current tariffClassId into the built list
                    v_tariffClassIdFound := v_tariffClassIdFound & v_tariffClassId & ";";
                } // End of 'for' statement
            } // End of 'for' statement
            
            return true;
        } // End of function f_check_uniqueness_tariffClassID
        
        /**
         * @desc    This function verifies the presence of Currency Conversion Table when alternative currency is valid for a tariff class
         * @param   p_tariffsList Tariff list
         * @return  true on success, false otherwise
         * @verdict unchanged
         */
        function f_check_currencyConversionTable(
                                                 in TariffTables p_tariffTables
        ) runs on EutComp return boolean {
            // StandardCurrency is a mandatory field, no need to check it

            for (var integer v_counter := 0; v_counter < sizeof(p_tariffTables); v_counter := v_counter + 1) {
                var TariffTable v_tariffsList := p_tariffTables[v_counter];
                
                // Parse Tariffs list
                for (var integer v_idx := 0; v_idx < sizeof(v_tariffsList.tariffs); v_idx := v_idx + 1) { // Loop on tariffs table
                    if (not ispresent(v_tariffsList.tariffs[v_idx].alternativeCurrency)) {
                        return false; // TT.Tariffs[i].alternativeCurrency shall be present 
                    }
                    // Verifies that the the same currency are defined
                    if (not match(v_tariffsList.tariffs[v_idx].alternativeCurrency, oct2int(v_tariffsList.standardCurrency))) {
                        return false;
                    }
                } // End of 'for' statement
            } // End of 'for' statement
            
            return true;
        } // End of function f_check_currencyConversionTable
        
        function f_roundingRules(
                                 in template (value) TariffTable p_tariffTable,
                                 in float p_curencyUnit
        ) runs on EutComp return float {
            if (p_tariffTable.tariffs[0].roundingRuleForChargeUnitsUsed == RoundingRule_no_) { // no rounding
                return p_curencyUnit;
            } else if (p_tariffTable.tariffs[0].roundingRuleForChargeUnitsUsed == RoundingRule_up_) { // always rounding up to next larger value of the minor curency unit
                return p_curencyUnit;
            } else if (p_tariffTable.tariffs[0].roundingRuleForChargeUnitsUsed == RoundingRule_down_) { // always rounding down to next lower value of the minor currency unit
                return p_curencyUnit;
            } // else, default is rounding according to accounting rules (as e.g. defined in DIN 1333)
            
            return p_curencyUnit;
        }
        
        /**
         * @desc    This function verifies fee calculation algorithm
         * @param   p_tariffsList Tariff list
         * @return  true on success, false otherwise
         * @verdict unchanged
         */
        function f_check_compliancy_TariffClass(
                                                in template (value) UsageStatementList p_usageStatementList, 
                                                in template (value) TariffTable p_tariffTable,
                                                in boolean p_applyRounding := false
        ) runs on EutComp return boolean {
            // p_usageStatementList shall not be omit
            var float v_sum1 := 0.0;
            var float v_sum2 := 0.0;
            var float v_N := 0.0;

            // Parse UsageStatement list
            for (var integer v_idx := 0; v_idx < sizeof(p_usageStatementList); v_idx := v_idx + 1) {
                // Check if aggregatedFee and aggregatedSingleTariffClassSession fields are present
                if (
                    (ispresent(p_usageStatementList[v_idx].usageStatement.aggregatedSingleTariffClassSession) == false) 
                ) {
                    if (ispresent(p_usageStatementList[v_idx].usageStatement.aggregatedFee) == true) {
                        if (
                            match(
                                oct2int(p_usageStatementList[v_idx].usageStatement.aggregatedFee.feeExclVat.paymentFeeUnit), 
                                p_tariffTable.tariffs[0].alternativeCurrency
                            )
                        ) { // AND usageStatementList[i].aggregatedFee is expressed in Currency1
                            v_sum2 := v_sum2 + int2float(p_usageStatementList[v_idx].usageStatement.aggregatedFee.feeExclVat.paymentFeeAmount);
                        }
                    } else {
                        continue;
                    }
                } else {
                    // Check 
                    if (
                        match(
                            p_tariffTable.tariffs[0].tariffClass,
                            p_usageStatementList[v_idx].usageStatement.aggregatedSingleTariffClassSession.currentTariffClass.tariffClassId
                        ) == true
                    ) { // ASTC.currentTariffClass equals to Tariff1 
                        if (ispresent(p_usageStatementList[v_idx].usageStatement.aggregatedSingleTariffClassSession.feeExclVat)) {
                            if (
                                match(
                                    oct2int(p_usageStatementList[v_idx].usageStatement.aggregatedSingleTariffClassSession.feeExclVat.paymentFeeUnit), 
                                    p_tariffTable.tariffs[0].alternativeCurrency
                                )
                            ) { // AND all ASTC.feeExclVat are expressed in Currency1
                                v_sum1 := v_sum1 + int2float(p_usageStatementList[v_idx].usageStatement.aggregatedSingleTariffClassSession.feeExclVat.paymentFeeAmount);
                            }
                        }
                    } // else continue
                }
            } // End of 'for' loop
            if (p_applyRounding) {
                    v_N := f_roundingRules(p_tariffTable, PX_UNIT_USED);
            } else {
                v_N := PX_UNIT_USED;
            }
            if (match(v_sum1, v_N * int2float(p_tariffTable.tariffs[0].basicFeePerChargeUnit))) { // AND sum of all ASTC.feeExclVat equals to N * conversionRate1 * BFPCU1 
                return true;
            } else if (match(v_sum2, v_N * int2float(p_tariffTable.tariffs[0].basicFeePerChargeUnit))) { // AND sum of all usageStatementList[i].aggregatedFee = NxBFPCU1
                return true;
            }
            
            return false;
        } // End of function f_check_compliancy_TariffClass

        /**
         * @desc    This function verifies whether each combination of time, vehicle, location and user class leads to exactly one Tariff Class in A22.tariffClasses[i]
         * @param   p_tariffClasses Tariff class list
         * @return  true on success, false otherwise
         * @verdict unchanged
         */
        function f_check_uniqueness_tariffClasses(
                                                  in TariffClassDefinition.tariffClasses p_tariffClasses
        ) runs on EutComp return boolean {
            // p_tariffClasses shall not be omit

            var charstring v_tariffClassSetFound := ";"; // Used to build the list of the tariff class {t, v, u, l} already processed
            var charstring v_tariffClassSet; // tariff class {t, v, u, l} currently processed
            var template charstring m_found_pattern; // Used in regex to verify that 'tariff class {t, v, u, l}' was not found before

            // Step0: Verify the uniqueness of in each list
            if (f_check_uniqueness_tariffClassID_1(p_tariffClasses) == false) {
                return false; // Error: Fail to verify the uniqueness of tariffClassId in the list
            }

            // Parse TariffClass classes
            for (var integer v_idx := 0; v_idx < sizeof(p_tariffClasses); v_idx := v_idx + 1) {
                // Step1: Verify the uniqueness in each list
                if (f_check_uniqueness_localVehicleClassId_1(p_tariffClasses[v_idx].localVehicleClasses) == false) {
                    return false; // Error: Fail to verify the uniqueness of localVehicleClassId
                }
                if (f_check_uniqueness_timeClassId_1(p_tariffClasses[v_idx].timeClasses) == false) {
                    return false; // Error: Fail to verify the uniqueness of timeClassId
                }
                if (f_check_uniqueness_locationClassId_1(p_tariffClasses[v_idx].locationClasses) == false) {
                    return false; // Error: Fail to verify the uniqueness of locationClassId
                }
                if (f_check_uniqueness_userClassId_1(p_tariffClasses[v_idx].userClasses) == false) {
                    return false; // Error: Fail to verify the uniqueness of userClassId
                }

                v_tariffClassSet := "";
                for (var integer v_localVehicleClasses_idx := 0; v_localVehicleClasses_idx < sizeof(p_tariffClasses[v_idx].localVehicleClasses); v_localVehicleClasses_idx := v_localVehicleClasses_idx + 1) {
                    v_tariffClassSet := v_tariffClassSet & "v" & int2str(p_tariffClasses[v_idx].localVehicleClasses[v_localVehicleClasses_idx]);
                } // End of 'for' statement
                for (var integer v_timeClasses_idx := 0; v_timeClasses_idx < sizeof(p_tariffClasses[v_idx].timeClasses); v_timeClasses_idx := v_timeClasses_idx + 1) {
                    v_tariffClassSet := v_tariffClassSet & "t" & int2str(p_tariffClasses[v_idx].timeClasses[v_timeClasses_idx]);
                } // End of 'for' statement
                for (var integer v_locationClasses_idx := 0; v_locationClasses_idx < sizeof(p_tariffClasses[v_idx].locationClasses); v_locationClasses_idx := v_locationClasses_idx + 1) {
                    v_tariffClassSet := v_tariffClassSet & "l" & int2str(p_tariffClasses[v_idx].locationClasses[v_locationClasses_idx]);
                } // End of 'for' statement
                for (var integer v_userClasses_idx := 0; v_userClasses_idx < sizeof(p_tariffClasses[v_idx].userClasses); v_userClasses_idx := v_userClasses_idx + 1) {
                    v_tariffClassSet := v_tariffClassSet & "u" & int2str(p_tariffClasses[v_idx].locationClasses[v_userClasses_idx]);
                } // End of 'for' statement
                m_found_pattern := pattern "*({v_tariffClassSet})*";
                if (regexp(v_tariffClassSetFound, m_found_pattern, 0) == v_tariffClassSet) {
                    return false; // 'tariff class {t, v, u, l}' exist at least 2 times, uniqueness is not verified
                }
                // 'tariff class {t, v, u, l}' non found, add current 'tariff class {t, v, u, l}' into the built list
                v_tariffClassSetFound := v_tariffClassSetFound & v_tariffClassSet & ";";
            } // End of 'for' statement

            return true;
        } // End of function f_check_uniqueness_tariffClasses

        /**
         * @desc    This function verifies the uniqueness of tariffclassid in TariffClass list
         * @param   p_tariffClasses TariffClass list
         * @return  true on success, false otherwise
         * @verdict unchanged
         */
        function f_check_uniqueness_tariffClassID_1(
                                                    in TariffClassDefinition.tariffClasses p_tariffClasses
        ) runs on EutComp return boolean {
            // p_tariffClasses shall not be omit

            var charstring v_tariffClassIdFound := ";"; // Used to build the list of the tariffClassId already processed
            var charstring v_tariffClassId; // tariffClassId currently processed
            var template charstring m_found_pattern; // Used in regex to verify that 'tariffClassId' was not found before

            // Parse Tariffs list
            for (var integer v_idx := 0; v_idx < sizeof(p_tariffClasses); v_idx := v_idx + 1) {
                v_tariffClassId := int2str(p_tariffClasses[v_idx].tariffClassId);
                m_found_pattern := pattern "*({v_tariffClassId})*";
                if (regexp(v_tariffClassIdFound, m_found_pattern, 0) == v_tariffClassId) {
                    return false; // tariffClassId exist at least 2 times, uniqueness is not verified
                }
                // tariffClassId non found, add current tariffClassId into the built list
                v_tariffClassIdFound := v_tariffClassIdFound & v_tariffClassId & ";";
            } // End of 'for' statement
            
            return true;
        } // End of function f_check_uniqueness_tariffClassID_1

        /**
         * @desc    This function verifies the uniqueness of localVehivleClassId in LocalVehicleClass list
         * @param   p_locvehclassList localVehivleClassId list
         * @return  true on success, false otherwise
         * @verdict unchanged
         */
        function f_check_uniqueness_localVehicleClassId(
                                                        in LocalVehicleClassDefinition.localVehicleClasses p_locvehclassList
        ) runs on EutComp return boolean {
            // p_locvehclassList shall not be omit

            var charstring v_localVehicleClassIdFound := ";"; // Used to build the list of the localVehicleClassId already processed
            var charstring v_localVehicleClassId; // localVehicleClassId currently processed
            var template charstring m_found_pattern; // Used in regex to verify that 'localVehicleClassId' was not found before

            // Parse LocalVehicleClasses list
            for (var integer v_idx := 0; v_idx < sizeof(p_locvehclassList); v_idx := v_idx + 1) {
                v_localVehicleClassId := int2str(p_locvehclassList[v_idx].localVehicleClassId);
                m_found_pattern := pattern "*({v_localVehicleClassId})*";
                if (regexp(v_localVehicleClassIdFound, m_found_pattern, 0) == v_localVehicleClassId) {
                    return false; // localVehicleClassId exist at least 2 times, uniqueness is not verified
                }
                // localVehicleClassId non found, add current localVehicleClassId into the built list
                v_localVehicleClassIdFound := v_localVehicleClassIdFound & v_localVehicleClassId & ";";
            } // End of 'for' statement
            
            return true;
        } // End of function f_check_uniqueness_localVehicleClassId

        /**
         * @desc    This function verifies the uniqueness of priorityValue in group of LocalVehicleClass items
         * @param   p_locvehclassList localVehivleClassId list
         * @return  true on success, false otherwise
         * @verdict unchanged
         */
        function f_check_uniqueness_priorityValue_by_group_localVehicleClass(
                                                                             in LocalVehicleClassDefinition.localVehicleClasses p_locvehclassList
        ) runs on EutComp return boolean {
            // p_locvehclassList shall not be omit

            var charstring v_priorityValueFound := ";"; // Used to build the list of the priorityValue already processed
            var charstring v_priorityValue; // priorityValue currently processed
            var template charstring m_found_pattern; // Used in regex to verify that 'priorityValue' was not found before

            var LocalVehicleClassesGroups v_groups := f_Build_localVehicleClass_groups(p_locvehclassList);

            // Parse v_groups list items
            for (var integer v_idx_groups := 0; v_idx_groups < sizeof(v_groups); v_idx_groups := v_idx_groups + 1) {
                v_priorityValueFound := ";"; // Reset found priorityValue list for the next processing
                var LocalVehicleClassDefinition.localVehicleClasses v_localVehicleClassesList := v_groups[v_idx_groups];
                // Parse all LocalVehicleClass items in the current group
                for (var integer v_idx := 0; v_idx < sizeof(v_localVehicleClassesList); v_idx := v_idx + 1) {
                    if (not ispresent(v_localVehicleClassesList[v_idx].priorityValue)) { // Step4: Verifies that 'priorityLevel' is present
                        return false; // Error: 'priorityLevel' is not present
                    }
                    v_priorityValue := int2str(v_localVehicleClassesList[v_idx].priorityValue);
                    m_found_pattern := pattern "*({v_priorityValue})*";
                    if (regexp(v_priorityValueFound, m_found_pattern, 0) == v_priorityValue) { // Step4: Verify that each localVehicleClass gets different priorityLevel within each group
                        return false; // priorityValue exist at least 2 times, uniqueness is not verified
                    }
                    // priorityValue non found, add current priorityValue into the built list
                    v_priorityValueFound := v_priorityValueFound & v_priorityValue & ";";
                } // End of 'for' statement
            } // End of 'for' statement
            
            return true;
        } // End of function f_check_uniqueness_priorityValue_by_group_localVehicleClass

        /**
         * @desc    This function verifies the uniqueness of timeClassId in TimeClasses list
         * @param   p_timeclassList timeClassId list
         * @return  true on success, false otherwise
         * @verdict unchanged
         */
        function f_check_uniqueness_timeClassId(
                                                in TimeClassDefinition.timeClasses p_timeclassList
        ) runs on EutComp return boolean {
            // p_timeclassList shall not be omit

            var charstring v_timeClassIdFound := ";"; // Used to build the list of the timeClassId already processed
            var charstring v_timeClassId; // timeClassId currently processed
            var template charstring m_found_pattern; // Used in regex to verify that 'timeClassClassId' was not found before

            // Parse TimeClass list
            for (var integer v_idx := 0; v_idx < sizeof(p_timeclassList); v_idx := v_idx + 1) {
                v_timeClassId := int2str(p_timeclassList[v_idx].timeClassId);
                m_found_pattern := pattern "*({v_timeClassId})*";
                if (regexp(v_timeClassIdFound, m_found_pattern, 0) == v_timeClassId) {
                    return false; // timeClassId exist at least 2 times, uniqueness is not verified
                }
                // timeClassId non found, add current timeClassId into the built list
                v_timeClassIdFound := v_timeClassIdFound & v_timeClassId & ";";
            } // End of 'for' statement
            
            return true;
        } // End of function f_check_uniqueness_timeClassId

        /**
         * @desc    This function verifies the uniqueness of priorityValue in group of TimeClass items
         * @param   p_timeclassList timerClassId list
         * @return  true on success, false otherwise
         * @verdict unchanged
         */
        function f_check_uniqueness_priorityValue_by_group_timeClass(
                                                                     in TimeClassDefinition.timeClasses p_timeclassList
        ) runs on EutComp return boolean {
            // p_timeclassList shall not be omit

            var charstring v_priorityValueFound := ";"; // Used to build the list of the priorityValue already processed
            var charstring v_priorityValue; // priorityValue currently processed
            var template charstring m_found_pattern; // Used in regex to verify that 'priorityValue' was not found before

            var TimeClassesGroups v_groups := f_build_timeClass_groups(p_timeclassList);

            // Parse v_groups list items
            for (var integer v_idx_groups := 0; v_idx_groups < sizeof(v_groups); v_idx_groups := v_idx_groups + 1) {
                v_priorityValueFound := ";"; // Reset found priorityValue list for the next processing
                var TimeClassDefinition.timeClasses v_timeClassesList := v_groups[v_idx_groups];
                // Parse all TimeClass items in the current group
                for (var integer v_idx := 0; v_idx < sizeof(v_timeClassesList); v_idx := v_idx + 1) {
                    v_priorityValue := int2str(v_timeClassesList[v_idx].priorityValue);
                    m_found_pattern := pattern "*({v_priorityValue})*";
                    if (regexp(v_priorityValueFound, m_found_pattern, 0) == v_priorityValue) { // Step4: Verify that each timeClass gets different priorityLevel within each group
                        return false; // priorityValue exist at least 2 times, uniqueness is not verified
                    }
                    // priorityValue non found, add current priorityValue into the built list
                    v_priorityValueFound := v_priorityValueFound & v_priorityValue & ";";
                } // End of 'for' statement
            } // End of 'for' statement
            
            return true;
        } // End of function f_check_uniqueness_priorityValue_by_group_timeClass

        /**
         * @desc    This function verifies the uniqueness of userClassId in userClasses list
         * @param   p_userclassList userClassId list
         * @return  true on success, false otherwise
         * @verdict unchanged
         */
        function f_check_uniqueness_userClassId(
                                                in UserClassDefinition.userClasses p_userclassList
        ) runs on EutComp return boolean {
            // p_userclassList shall not be omit

            var charstring v_userClassIdFound := ";"; // Used to build the list of the userClassId already processed
            var charstring v_userClassId; // userClassId currently processed
            var template charstring m_found_pattern; // Used in regex to verify that 'userClassId' was not found before

            // Parse TimeClass list
            for (var integer v_idx := 0; v_idx < sizeof(p_userclassList); v_idx := v_idx + 1) {
                v_userClassId := int2str(p_userclassList[v_idx].userClassId);
                m_found_pattern := pattern "*({v_userClassId})*";
                if (regexp(v_userClassIdFound, m_found_pattern, 0) == v_userClassId) {
                    return false; // userClassId exist at least 2 times, uniqueness is not verified
                }
                // userClassId non found, add current userClassId into the built list
                v_userClassIdFound := v_userClassIdFound & v_userClassId & ";";
            } // End of 'for' statement
            
            return false; // Error
        } // End of function f_check_uniqueness_userClassId

        /**
         * @desc    This function verifies the uniqueness of priorityValue in group of UserClass items
         * @param   p_usertclassList userClassId list
         * @return  true on success, false otherwise
         * @verdict unchanged
         */
        function f_check_uniqueness_priorityValue_by_group_userClass(
                                                                     in UserClassDefinition.userClasses p_usertclassList
        ) runs on EutComp return boolean {
            // p_usertclassList shall not be omit

            var UserClassesGroups v_groups := f_build_userClass_groups(p_usertclassList);
            // Parse v_groups list items
            for (var integer v_idx_groups := 0; v_idx_groups < sizeof(v_groups); v_idx_groups := v_idx_groups + 1) {
                if (sizeof(v_groups[v_idx_groups]) != 1) { // Step4: Verify that each group consists of exactly one user class
                    return false; // Error
                }
            } // End of 'for' statement
            
            return true;
        } // End of function f_check_uniqueness_priorityValue_by_group_userClass

        /**
         * @desc    This function checks that the Layout Description is compliant to Toll Scheme Type
         * @param   p_tollcontextoverview TollContextOverview value
         * @param   p_tollContextPartitionLayout TollContextLayout value
         * @return  true on success, false otherwise
         * @verdict fail if unreachable code is executed, unchanged otherwise
         */
        function f_check_compliancy_tollContextLayout_tollSchemeType(
                                                                     in template (value) TollContextOverview p_tollcontextoverview, 
                                                                     in template (value) TollContextPartitionOverviews p_tollContextPartitionOverviews,
                                                                     in template (value) TollContextPartitionLayouts p_tollContextPartitionLayouts
        ) runs on EutComp return boolean {
            // p_tollContextPartitionLayout shall not be omit
            
            var integer v_idx;
            
            // Assume that p_tollContextPartitionLayouts are in the same ordered regarding p_tollcontextoverview.tollContextPartitions
            for (v_idx := 0; v_idx < sizeof(p_tollcontextoverview.tollContextPartitions); v_idx := v_idx + 1) {
                
                if (p_tollContextPartitionOverviews[v_idx].tollContextPartitionType == TollSchemeType_roadSectionPricing_) {
                    if (not ischosen(p_tollContextPartitionLayouts[v_idx].layoutDescription.sectionPricingLayout)) {
                        return false;
                    }
                }
                if (
                    (p_tollContextPartitionOverviews[v_idx].tollContextPartitionType == TollSchemeType_areaPricingDistance_) or 
                    (p_tollContextPartitionOverviews[v_idx].tollContextPartitionType == TollSchemeType_areaPricingTime_)
                ) {
                    if (not ischosen(p_tollContextPartitionLayouts[v_idx].layoutDescription.areaPricingLayout)) {
                        return false;
                    }
                }
                if (p_tollContextPartitionOverviews[v_idx].tollContextPartitionType == TollSchemeType_cordonPricing_) {
                    if (not ischosen(p_tollContextPartitionLayouts[v_idx].layoutDescription.cordonPricingLayout)) {
                        return false;
                    }
                }
                
            } // End of 'for' statement

            return true;
        } // End of function f_check_compliancy_tollContextLayout_tollSchemeType

        /**
         * @desc    This function checks that that one toll context shall have one or more toll context partition layout descriptions, one per defined toll context partition
         * @param   p_tollcontextoverview TollContextOverview value
         * @param   p_tollContextPartitionLayout TollContextLayout value
         * @return  true on success, false otherwise
         * @verdict fail if unreachable code is executed, unchanged otherwise
         */
        function f_check_compliancy_tollContextOverview_tollContextPartitionLayout(
                                                                                   in template (value) TollContextOverview p_tollContextOverview, 
                                                                                   in template (value) TollContextPartitionLayouts p_tollContextLayout
        ) runs on EutComp return boolean {
            // p_tollContextLayout shall not be omit
            
            var integer v_idx;
            
            // Assume that p_tollContextPartitionLayouts are in the same ordered regarding p_tollcontextoverview.tollContextPartitions
            for (v_idx := 0; v_idx < sizeof(p_tollContextOverview.tollContextPartitions); v_idx := v_idx + 1) {
                // Search for p_tollContextOverview.tollContextPartitions[v_idx] into p_tollContextLayout
                if (not match(p_tollContextLayout, superset(mw_tollContextPartitionLayout(p_tollContextOverview.tollContextPartitions[v_idx])))) {
                    return false;
                }
            } // End of 'for' loop
            
            return true;
        } // End of function f_check_compliancy_tollContextOverview_tollContextPartitionLayout

        /**
         * @desc    Functions for TCs related to Section Pricing Layout
         * @see     [17575-3:2016], Clause 8.5.4.2.2 Data element sectionLayout/Data type SectionLayout
         */
        group Section_Pricing_Layout {
            /**
             * @desc    This function verifies the uniqueness of Charge Object ID in SectionPricingLayout
             * @param   p_tollContextPartitionLayout TollContextPartitionLayouts list
             * @return  true on success, false otherwise
             * @verdict unchanged
             */
            function f_check_uniqueness_tollContextLayout_sectionPricingLayout_chargeObjectId(
                                                                                              in template(value) TollContextPartitionLayouts p_tollContextPartitionLayout
            ) runs on EutComp return boolean {
                
                var charstring v_chargeObjectIdFound := ";"; // Used to build the list of the chargeObjectId already processed
                var charstring v_chargeObjectId; // chargeObjectId currently processed
                var template charstring m_found_pattern; // Used in regex to verify that 'chargeObjectId' was not found before
                
                for (var integer v_counter := 0; v_counter < sizeof(p_tollContextPartitionLayout); v_counter := v_counter + 1) {
                    if (ischosen(p_tollContextPartitionLayout[v_counter].layoutDescription.cordonPricingLayout)) {
                        var Layout.sectionPricingLayout.sectionLayoutDescription v_sectionPricingLayout := p_tollContextPartitionLayout[v_counter].layoutDescription.sectionPricingLayout.sectionLayoutDescription;
                        
                        // Parse SectionLayout list
                        for (var integer v_idx := 0; v_idx < sizeof(v_sectionPricingLayout); v_idx := v_idx + 1) {
                            v_chargeObjectId := int2str(v_sectionPricingLayout[v_idx].chargeObjectId);
                            m_found_pattern := pattern "*({v_chargeObjectId})*";
                            if (regexp(v_chargeObjectIdFound, m_found_pattern, 0) == v_chargeObjectId) {
                                return false; // chargeObjectId exist at least 2 times, uniqueness is not verified
                            }
                            // chargeObjectId non found, add current chargeObjectId into the built list
                            v_chargeObjectIdFound := v_chargeObjectIdFound & v_chargeObjectId & ";";
                        } // End of 'for' statement
                    }
                } // End of 'for' statement
                
                return true;
            } // End of function f_check_uniqueness_tollContextLayout_sectionPricingLayout_chargeObjectId
    
            /**
             * @desc    This function verifies the uniqueness of Point ID in SectionPricingLayout
             * @param   p_tollContextPartitionLayout TollContextPartitionLayouts list
             * @return  true on success, false otherwise
             * @verdict unchanged
             */
            function f_check_uniqueness_tollContextLayout_sectionPricingLayout_pointId(
                                                                                       in template(value) TollContextPartitionLayouts p_tollContextPartitionLayout
            ) runs on EutComp return boolean {
                
                var charstring v_pointIdFound := ";"; // Used to build the list of the pointId already processed
                var charstring v_pointId; // pointId currently processed
                var template charstring m_found_pattern; // Used in regex to verify that 'pointId' was not found before
                
                for (var integer v_counter := 0; v_counter < sizeof(p_tollContextPartitionLayout); v_counter := v_counter + 1) {
                    if (ischosen(p_tollContextPartitionLayout[v_counter].layoutDescription.cordonPricingLayout)) {
                        var Layout.sectionPricingLayout.sectionLayoutDescription v_sectionPricingLayout := p_tollContextPartitionLayout[v_counter].layoutDescription.sectionPricingLayout.sectionLayoutDescription;
                        
                        // Parse SectionLayout list
                        for (var integer v_idx := 0; v_idx < sizeof(v_sectionPricingLayout); v_idx := v_idx + 1) {
                            if (ispresent(v_sectionPricingLayout[v_idx].networkPoints)) {
                                var SectionLayout.networkPoints v_networkPoints := v_sectionPricingLayout[v_idx].networkPoints;
                                v_pointIdFound := ";"; // Reset found pattern
                                for (var integer v_jdx := 0; v_jdx < sizeof(v_networkPoints); v_jdx := v_jdx + 1) {
                                    v_pointId := int2str(v_networkPoints[v_jdx].pointId);
                                    m_found_pattern := pattern "*({v_pointId})*";
                                    if (regexp(v_pointIdFound, m_found_pattern, 0) == v_pointId) {
                                        return false; // pointId exist at least 2 times, uniqueness is not verified
                                    }
                                    // pointId non found, add current pointId into the built list
                                    v_pointIdFound := v_pointIdFound & v_pointId & ";";
                                } // End of 'for' statement
                            }
                        } // End of 'for' statement
                    }
                } // End of 'for' statement
                
                return true;
            } // End of function f_check_uniqueness_tollContextLayout_sectionPricingLayout_pointId
    
            /**
             * @desc    This function verifies the uniqueness of link ID in SectionPricingLayout
             * @param   p_tollContextPartitionLayout TollContextPartitionLayouts list
             * @return  true on success, false otherwise
             * @verdict unchanged
             */
            function f_check_uniqueness_tollContextLayout_sectionPricingLayout_linkId(
                                                                                      in template(value) TollContextPartitionLayouts p_tollContextPartitionLayout
            ) runs on EutComp return boolean {
                
                var charstring v_linkIdFound := ";"; // Used to build the list of the linkId already processed
                var charstring v_linkId; // linkId currently processed
                var template charstring m_found_pattern; // Used in regex to verify that 'linkId' was not found before
                
                for (var integer v_counter := 0; v_counter < sizeof(p_tollContextPartitionLayout); v_counter := v_counter + 1) {
                    if (ischosen(p_tollContextPartitionLayout[v_counter].layoutDescription.cordonPricingLayout)) {
                        var Layout.sectionPricingLayout.sectionLayoutDescription v_sectionPricingLayout := p_tollContextPartitionLayout[v_counter].layoutDescription.sectionPricingLayout.sectionLayoutDescription;
                        
                        // Parse SectionLayout list
                        for (var integer v_idx := 0; v_idx < sizeof(v_sectionPricingLayout); v_idx := v_idx + 1) {
                            v_linkId := int2str(v_sectionPricingLayout[v_idx].tollPath.linkId);
                            m_found_pattern := pattern "*({v_linkId})*";
                            if (regexp(v_linkIdFound, m_found_pattern, 0) == v_linkId) {
                                return false; // linkId exist at least 2 times, uniqueness is not verified
                            }
                            // linkId non found, add current linkId into the built list
                            v_linkIdFound := v_linkIdFound & v_linkId & ";";
                        } // End of 'for' statement
                    }
                } // End of 'for' statement
                
                return true;
            } // End of function f_check_uniqueness_tollContextLayout_sectionPricingLayout_linkId
    
            /**
             * @desc    This function verifies that each point (i.e. startPoint, endPoint, listOfIntermediatePoints) defined in each Link of TollContextLayout has defined pointIdentifier EX-OR pointCoordinates 
             * @param   p_tollContextPartitionLayout TollContextPartitionLayouts list
             * @return  true on success, false otherwise
             * @verdict unchanged
             */
            function f_check_uniqueness_tollContextLayout_sectionPricingLayout_pointDescription_link(
                                                                                                     in template(value) TollContextPartitionLayouts p_tollContextPartitionLayout
            ) runs on EutComp return boolean {
                
                for (var integer v_counter := 0; v_counter < sizeof(p_tollContextPartitionLayout); v_counter := v_counter + 1) {
                    if (ischosen(p_tollContextPartitionLayout[v_counter].layoutDescription.cordonPricingLayout)) {
                        var Layout.sectionPricingLayout.sectionLayoutDescription v_sectionPricingLayout := p_tollContextPartitionLayout[v_counter].layoutDescription.sectionPricingLayout.sectionLayoutDescription;
                        
                        // Parse SectionLayout list
                        for (var integer v_idx := 0; v_idx < sizeof(v_sectionPricingLayout); v_idx := v_idx + 1) {
                            var Link v_link := v_sectionPricingLayout[v_idx].tollPath;
                            
                            if (f_check_point(v_link.startPoint) == false) {
                                return false; // Both field of Point data structure are defined ==> conflict
                            }
                            if (f_check_point(v_link.endPoint) == false) {
                                return false; // Both field of Point data structure are defined ==> conflict
                            }
                            if (ispresent(v_link.intermediatePoints)) {
                                // Parse intermediatePoints
                                for (var integer v_jdx := 0; v_jdx < sizeof(v_link.intermediatePoints); v_jdx := v_jdx + 1) {
                                    if (f_check_point(v_link.intermediatePoints[v_jdx]) == false) {
                                        return false; // Both field of Point data structure are defined ==> conflict
                                    }
                                } // End of 'for' statement
                            } // else ignore it
                        } // End of 'for' statement
                    }
                } // End of 'for' statement
                
                return true;
            } // End of function f_check_uniqueness_tollContextLayout_sectionPricingLayout_pointDescription_link
    
            /**
             * @desc    This function verifies that Point identified by Point ID in Link has been defined in Used Points
             * @param   p_tollContextPartitionLayout TollContextPartitionLayouts list
             * @return  true on success, false otherwise
             * @verdict unchanged
             */
            function f_check_uniqueness_tollContextLayout_sectionPricingLayout_link_pointID_networkPoints(
                                                                                                          in template(value) TollContextPartitionLayouts p_tollContextPartitionLayout
            ) runs on EutComp return boolean {
                
                for (var integer v_counter := 0; v_counter < sizeof(p_tollContextPartitionLayout); v_counter := v_counter + 1) {
                    if (ischosen(p_tollContextPartitionLayout[v_counter].layoutDescription.cordonPricingLayout)) {
                        var Layout.sectionPricingLayout.sectionLayoutDescription v_sectionPricingLayout := p_tollContextPartitionLayout[v_counter].layoutDescription.sectionPricingLayout.sectionLayoutDescription;
                        
                        // Parse SectionLayout list
                        for (var integer v_idx := 0; v_idx < sizeof(v_sectionPricingLayout); v_idx := v_idx + 1) {
                            var Link v_link := v_sectionPricingLayout[v_idx].tollPath;
                            
                            if (not ispresent(v_sectionPricingLayout[v_idx].networkPoints)) { // No pointID defined
                                if (ischosen(v_link.startPoint.pointIdentifier)) {
                                    return false; // PointID is defined with an empty list of PointIDs
                                }
                                if (ischosen(v_link.endPoint.pointIdentifier)) {
                                    return false; // PointID is defined with an empty list of PointIDs
                                }
                                if (ispresent(v_link.intermediatePoints)) {
                                    // Parse intermediatePoints
                                    for (var integer v_jdx := 0; v_jdx < sizeof(v_link.intermediatePoints); v_jdx := v_jdx + 1) {
                                        if (ischosen(v_link.intermediatePoints[v_jdx].pointIdentifier)) {
                                            return false; // PointID is defined with an empty list of PointIDs
                                        }
                                    } // End of 'for' statement
                                } // else ignore it
                            } else { // A list of pointID is defined
                                var charstring v_pointIdFound := f_build_pointId_sectionLayout_networkPoints(v_sectionPricingLayout[v_idx].networkPoints); // Build the list of the pointId declared in networkPoints
                                var charstring v_pointId := "";
                                var template charstring m_found_pattern; // Used in regex to verify that 'pointId' was not found before
                                
                                if (ischosen(v_link.startPoint.pointIdentifier)) {
                                    v_pointId := int2str(v_link.startPoint.pointIdentifier);
                                    m_found_pattern := pattern "*({v_pointId})*";
                                    if (regexp(v_pointIdFound, m_found_pattern, 0) != v_pointId) {
                                        return false; // pointId does not exist
                                    }
                                }
                                if (ischosen(v_link.endPoint.pointIdentifier)) {
                                    v_pointId := int2str(v_link.endPoint.pointIdentifier);
                                    m_found_pattern := pattern "*({v_pointId})*";
                                    if (regexp(v_pointIdFound, m_found_pattern, 0) != v_pointId) {
                                        return false; // pointId does not exist
                                    }
                                }
                                if (ispresent(v_link.intermediatePoints)) {
                                    // Parse intermediatePoints
                                    for (var integer v_jdx := 0; v_jdx < sizeof(v_link.intermediatePoints); v_jdx := v_jdx + 1) {
                                        if (ischosen(v_link.intermediatePoints[v_jdx].pointIdentifier)) {
                                            v_pointId := int2str(v_link.intermediatePoints[v_jdx].pointIdentifier);
                                            m_found_pattern := pattern "*({v_pointId})*";
                                            if (regexp(v_pointIdFound, m_found_pattern, 0) != v_pointId) {
                                                return false; // pointId does not exist
                                            }
                                        }
                                    } // End of 'for' statement
                                } // else ignore it
                            }
                        } // End of 'for' statement
                    }
                } // End of 'for' statement
                
                return true;
            } // End of function f_check_uniqueness_tollContextLayout_sectionPricingLayout_link_pointID_networkPoints
            
// TODO To be removed
//            /**
//             * @desc    This function verifies that each point (i.e. startPoint, endPoint, intermediatePoints) defined in each LiabilityRules of TollContextLayout has defined pointIdentifier EX-OR pointCoordinates 
//             * @param   p_sectionLayoutList SectionLayout list
//             * @return  true on success, false otherwise
//             * @verdict unchanged
//             */
//            function f_check_uniqueness_TollContextLayout_SectionPricingLayout_pointDescription_LiabilityRules(
//                                                                                                               in Layout.sectionPricingLayout p_sectionLayoutList
//            ) runs on EutComp return boolean {
//                // p_sectionLayoutList shall not be omit
//    
//                // Parse SectionLayout list
//                for (var integer v_idx := 0; v_idx < sizeof(p_sectionLayoutList.sectionLayoutDescription); v_idx := v_idx + 1) {
//                    var LiabilityRules v_liabilityRules := p_sectionLayoutList.sectionLayoutDescription[v_idx].liabilityRules;
//    
//                    if (f_check_point(v_liabilityRules.tollPoints[0]) == false) {
//                        return false; // Both field of Point data structure are defined ==> conflict
//                    }
//                    if (f_check_point(v_liabilityRules.tollPoints[1]) == false) {
//                        return false; // Both field of Point data structure are defined ==> conflict
//                    }
//                } // End of 'for' statement
//    
//                return true;
//            } // End of function f_check_uniqueness_TollContextLayout_SectionPricingLayout_pointDescription_LiabilityRules
//    
            /**
             * @desc    This function verifies that Point identified by Point ID in Liability Rules has been defined in Network Points
             * @param   p_tollContextPartitionLayout TollContextPartitionLayouts list
             * @return  true on success, false otherwise
             * @verdict unchanged
             */
            function f_check_uniqueness_tollContextLayout_sectionPricingLayout_liabilityRules_pointID_networkPoints(
                                                                                                                    in template(value) TollContextPartitionLayouts p_tollContextPartitionLayout
            ) runs on EutComp return boolean {
                
                for (var integer v_counter := 0; v_counter < sizeof(p_tollContextPartitionLayout); v_counter := v_counter + 1) {
                    if (ischosen(p_tollContextPartitionLayout[v_counter].layoutDescription.cordonPricingLayout)) {
                        var Layout.sectionPricingLayout.sectionLayoutDescription v_sectionPricingLayout := p_tollContextPartitionLayout[v_counter].layoutDescription.sectionPricingLayout.sectionLayoutDescription;
                        
                        // Parse SectionLayout list
                        for (var integer v_idx := 0; v_idx < sizeof(v_sectionPricingLayout); v_idx := v_idx + 1) {
                            var LiabilityRules v_liabilityRules := v_sectionPricingLayout[v_idx].liabilityRules;
                            
                            if (not ispresent(v_sectionPricingLayout[v_idx].networkPoints)) { // No pointID defined
                                if (ischosen(v_liabilityRules.tollPoints[0].pointIdentifier)) {
                                    return false; // PointID is defined with an empty list of PointIDs
                                }
                                if (ischosen(v_liabilityRules.tollPoints[1].pointIdentifier)) {
                                    return false; // PointID is defined with an empty list of PointIDs
                                }
                            } else { // A list of pointID is defined
                                var charstring v_pointIdFound := f_build_pointId_sectionLayout_networkPoints(v_sectionPricingLayout[v_idx].networkPoints); // Build the list of the pointId declared in networkPoints
                                var charstring v_pointId := "";
                                var template charstring m_found_pattern; // Used in regex to verify that 'pointId' was not found before
                                
                                if (ischosen(v_liabilityRules.tollPoints[0].pointIdentifier)) {
                                    v_pointId := int2str(v_liabilityRules.tollPoints[0].pointIdentifier);
                                    m_found_pattern := pattern "*({v_pointId})*";
                                    if (regexp(v_pointIdFound, m_found_pattern, 0) != v_pointId) {
                                        return false; // pointId does not exist
                                    }
                                }
                                if (ischosen(v_liabilityRules.tollPoints[1].pointIdentifier)) {
                                    v_pointId := int2str(v_liabilityRules.tollPoints[1].pointIdentifier);
                                    m_found_pattern := pattern "*({v_pointId})*";
                                    if (regexp(v_pointIdFound, m_found_pattern, 0) != v_pointId) {
                                        return false; // pointId does not exist
                                    }
                                }
                            }
                        } // End of 'for' statement
                    }
                } // End of 'for' statement
                
                return true;
            } // End of function f_check_uniqueness_tollContextLayout_sectionPricingLayout_liabilityRules_pointID_networkPoints
            
// TODO To be removed
//            /**
//             * @desc    This function verifies that each point (i.e. startPoint, endPoint, intermediatePoints) defined in each SupportingPoint of TollContextLayout has defined pointIdentifier EX-OR pointCoordinates
//             * @param   p_sectionLayoutList SectionLayout list
//             * @return  true on success, false otherwise
//             * @verdict unchanged
//             */
//            function f_check_uniqueness_TollContextLayout_SectionPricingLayout_pointDescription_SupportingPoint(
//                                                                                                                in Layout.sectionPricingLayout p_sectionLayoutList
//            ) runs on EutComp return boolean {
//                // p_sectionLayoutList.sectionLayoutDescription shall not be omit
//    
//                // Parse SectionLayout list
//                for (var integer v_idx := 0; v_idx < sizeof(p_sectionLayoutList.sectionLayoutDescription); v_idx := v_idx + 1) {
//                    if (ispresent(p_sectionLayoutList.sectionLayoutDescription[v_idx].supportingInformation)) {
//                        for (var integer v_jdx := 0; v_jdx < sizeof(p_sectionLayoutList.sectionLayoutDescription[v_idx].supportingInformation); v_jdx := v_jdx + 1) {
//                            var SupportingPoint v_supportingPoint := p_sectionLayoutList.sectionLayoutDescription[v_idx].supportingInformation[v_jdx];
//                            if (ispresent(v_supportingPoint.supportPoint)) {
//                                if (f_check_point(v_supportingPoint.supportPoint) == false) {
//                                    return false; // Both field of Point data structure are defined ==> conflict
//                                }
//                            }
//                        } // End of 'for' statement
//                    } // else continue
//                } // End of 'for' statement
//    
//                return true;
//            } // End of function f_check_uniqueness_TollContextLayout_SectionPricingLayout_pointDescription_SupportingPoint
//    
            /**
             * @desc    This function verifies that Point identified by Point ID in SupportingPoint has been defined in Network Points
             * @param   p_tollContextPartitionLayout TollContextPartitionLayouts list
             * @return  true on success, false otherwise
             * @verdict unchanged
             */
            function f_check_uniqueness_tollContextLayout_sectionPricingLayout_supportingPoint_pointID_networkPoints(
                                                                                                                     in template(value) TollContextPartitionLayouts p_tollContextPartitionLayout
            ) runs on EutComp return boolean {
                
                for (var integer v_counter := 0; v_counter < sizeof(p_tollContextPartitionLayout); v_counter := v_counter + 1) {
                    if (ischosen(p_tollContextPartitionLayout[v_counter].layoutDescription.cordonPricingLayout)) {
                        var Layout.sectionPricingLayout.sectionLayoutDescription v_sectionPricingLayout := p_tollContextPartitionLayout[v_counter].layoutDescription.sectionPricingLayout.sectionLayoutDescription;
                        
                        // Parse SectionLayout list
                        for (var integer v_idx := 0; v_idx < sizeof(v_sectionPricingLayout); v_idx := v_idx + 1) {
                            if (ispresent(v_sectionPricingLayout[v_idx].supportingInformation)) {
                                for (var integer v_jdx := 0; v_jdx < sizeof(v_sectionPricingLayout[v_idx].supportingInformation); v_jdx := v_jdx + 1) {
                                    var SupportingPoint v_supportingPoint := v_sectionPricingLayout[v_idx].supportingInformation[v_jdx];
                                    if (ispresent(v_supportingPoint.supportPoint)) {
                                        if (not ispresent(v_sectionPricingLayout[v_idx].networkPoints)) { // No pointID defined
                                            if (ischosen(v_supportingPoint.supportPoint.pointIdentifier)) {
                                                return false; // PointID is defined with an empty list of PointIDs
                                            }
                                        } else { // A list of pointID is defined
                                            var charstring v_pointIdFound := f_build_pointId_sectionLayout_networkPoints(v_sectionPricingLayout[v_idx].networkPoints); // Build the list of the pointId declared in networkPoints
                                            var charstring v_pointId := "";
                                            var template charstring m_found_pattern; // Used in regex to verify that 'pointId' was not found before
                                            
                                            if (ischosen(v_supportingPoint.supportPoint.pointIdentifier)) {
                                                v_pointId := int2str(v_supportingPoint.supportPoint.pointIdentifier);
                                                m_found_pattern := pattern "*({v_pointId})*";
                                                if (regexp(v_pointIdFound, m_found_pattern, 0) != v_pointId) {
                                                    return false; // pointId does not exist
                                                }
                                            }
                                        }
                                    } // ispresent(v_supportingPoint.supportPoint)
                                } // End of 'for' statement
                            } // else continue
                        } // End of 'for' statement
                    }
                } // End of 'for' statement
                
                return true;
            } // End of function f_check_uniqueness_tollContextLayout_sectionPricingLayout_supportingPoint_pointID_networkPoints

            /**
             * @desc    This function verifies the uniqueness of time class ID in SectionPricingLayout
             * @param   p_tollContextPartitionLayout TollContextPartitionLayouts list
             * @return  true on success, false otherwise
             * @verdict unchanged
             */
            function f_check_uniqueness_tollContextLayout_sectionPricingLayout_timeClassId(
                                                                                           in template(value) TollContextPartitionLayouts p_tollContextPartitionLayout
            ) runs on EutComp return boolean {
                
                var charstring v_timeClassIdFound := ";"; // Used to build the list of the timeClassId already processed
                var charstring v_timeClassId; // timeClassId currently processed
                var template charstring m_found_pattern; // Used in regex to verify that 'timeClassId' was not found before
                
                for (var integer v_counter := 0; v_counter < sizeof(p_tollContextPartitionLayout); v_counter := v_counter + 1) {
                    if (ischosen(p_tollContextPartitionLayout[v_counter].layoutDescription.cordonPricingLayout)) {
                        var Layout.sectionPricingLayout.sectionLayoutDescription v_sectionPricingLayout := p_tollContextPartitionLayout[v_counter].layoutDescription.sectionPricingLayout.sectionLayoutDescription;
                        
                        // Parse SectionLayout list
                        for (var integer v_idx := 0; v_idx < sizeof(v_sectionPricingLayout); v_idx := v_idx + 1) {
                            if (ispresent(v_sectionPricingLayout[v_idx].applicableTimeClasses)) {
                                v_timeClassIdFound := ";";
                                for (var integer v_jdx := 0; v_jdx < sizeof(v_sectionPricingLayout[v_idx].applicableTimeClasses); v_jdx := v_jdx + 1) {
                                    v_timeClassId := int2str(v_sectionPricingLayout[v_idx].applicableTimeClasses[v_jdx]);
                                    m_found_pattern := pattern "*({v_timeClassId})*";
                                    if (regexp(v_timeClassIdFound, m_found_pattern, 0) == v_timeClassId) {
                                        return false; // timeClassId exist at least 2 times, uniqueness is not verified
                                    }
                                    // timeClassId non found, add current timeClassId into the built list
                                    v_timeClassIdFound := v_timeClassIdFound & v_timeClassId & ";";
                                } // End of 'for' statement
                            } // ispresent(p_sectionLayoutList[v_idx].applicableTimeClasses)
                        } // End of 'for' statement
                    }
                } // End of 'for' statement
                
                return true;
            } // End of function f_check_uniqueness_tollContextLayout_sectionPricingLayout_timeClassId

        } // End of group Section_Pricing_Layout

        /**
         * @desc    Functions for TCs related to Area Pricing Layout
         * @see     [17575-3:2016], 8.3.4.2. Data element areaLayout
         */
        group Area_Pricing_Layout {
            /**
             * @desc    This function verifies the uniqueness of area ID in AreaLayout
             * @param   p_tollContextPartitionLayout TollContextPartitionLayouts list
             * @return  true on success, false otherwise
             * @verdict unchanged
             */
            function f_check_uniqueness_tollContextLayout_areaPricingLayout_areaId(
                                                                                   in template(value) TollContextPartitionLayouts p_tollContextPartitionLayout
            ) runs on EutComp return boolean {
                
                var charstring v_areaIdFound := ";"; // Used to build the list of the areaId already processed
                var charstring v_areaId; // areaId currently processed
                var template charstring m_found_pattern; // Used in regex to verify that 'areaId' was not found before
                
                for (var integer v_counter := 0; v_counter < sizeof(p_tollContextPartitionLayout); v_counter := v_counter + 1) {
                    if (ischosen(p_tollContextPartitionLayout[v_counter].layoutDescription.areaPricingLayout)) {
                        var Layout.areaPricingLayout v_areaLayoutList := p_tollContextPartitionLayout[v_counter].layoutDescription.areaPricingLayout;
                        
                        // Parse AreaLayout list
                        for (var integer v_idx := 0; v_idx < sizeof(v_areaLayoutList); v_idx := v_idx + 1) {
                            v_areaId := int2str(v_areaLayoutList[v_idx].areaId);
                            m_found_pattern := pattern "*({v_areaId})*";
                            if (regexp(v_areaIdFound, m_found_pattern, 0) == v_areaId) {
                                return false; // areaId exist at least 2 times, uniqueness is not verified
                            }
                            // areaId non found, add current areaId into the built list
                            v_areaIdFound := v_areaIdFound & v_areaId & ";";
                        } // End of 'for' statement
                    }
                } // End of 'for' statement
                
                return true;
            } // End of function f_check_uniqueness_tollContextLayout_areaPricingLayout_areaId

            /**
             * @desc    This function verifies the uniqueness of Charge Object ID in AreaPricingLayout
             * @param   p_tollContextPartitionLayout TollContextPartitionLayouts list
             * @return  true on success, false otherwise
             * @verdict unchanged
             */
            function f_check_uniqueness_tollContextLayout_areaPricingLayout_chargeObjectId(
                                                                                           in template(value) TollContextPartitionLayouts p_tollContextPartitionLayout
            ) runs on EutComp return boolean {
                
                var charstring v_chargeObjectIdFound := ";"; // Used to build the list of the chargeObjectId already processed
                var charstring v_chargeObjectId; // chargeObjectId currently processed
                var template charstring m_found_pattern; // Used in regex to verify that 'chargeObjectId' was not found before
                
                for (var integer v_counter := 0; v_counter < sizeof(p_tollContextPartitionLayout); v_counter := v_counter + 1) {
                    if (ischosen(p_tollContextPartitionLayout[v_counter].layoutDescription.areaPricingLayout)) {
                        var Layout.areaPricingLayout v_areaLayoutList := p_tollContextPartitionLayout[v_counter].layoutDescription.areaPricingLayout;
                        
                        // Parse AreaLayout list
                        for (var integer v_idx := 0; v_idx < sizeof(v_areaLayoutList); v_idx := v_idx + 1) {
                            // Parse RoadNetwork list
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_areaLayoutList[v_idx].roadNetworks); v_jdx := v_jdx + 1) {
                                v_chargeObjectIdFound := ";"; // Reset found list
                                // Parse RoadNetworkObjects list
                                for (var integer v_kdx := 0; v_kdx < sizeof(v_areaLayoutList[v_idx].roadNetworks[v_jdx].roadNetworkObjects); v_kdx := v_kdx + 1) {
                                    v_chargeObjectId := int2str(v_areaLayoutList[v_idx].roadNetworks[v_jdx].roadNetworkObjects[v_kdx].chargeObjectId);
                                    m_found_pattern := pattern "*({v_chargeObjectId})*";
                                    if (regexp(v_chargeObjectIdFound, m_found_pattern, 0) == v_chargeObjectId) {
                                        return false; // chargeObjectId exist at least 2 times, uniqueness is not verified
                                    }
                                    // chargeObjectId non found, add current chargeObjectId into the built list
                                    v_chargeObjectIdFound := v_chargeObjectIdFound & v_chargeObjectId & ";";
                                } // End of 'for' statement
                            } // End of 'for' statement
                        } // End of 'for' statement
                    }
                } // End of 'for' statement
                
                return true;
            } // End of function f_check_uniqueness_tollContextLayout_areaPricingLayout_chargeObjectId

            /**
             * @desc    This function verifies the uniqueness of Point ID in AreaPricingLayout
             * @param   p_tollContextPartitionLayout TollContextPartitionLayouts list
             * @return  true on success, false otherwise
             * @verdict unchanged
             */
            function f_check_uniqueness_tollContextLayout_areaPricingLayout_pointId(
                                                                                    in template(value) TollContextPartitionLayouts p_tollContextPartitionLayout
            ) runs on EutComp return boolean {
                
                var charstring v_pointIdFound := ";"; // Used to build the list of the pointId already processed
                var charstring v_pointId; // pointId currently processed
                var template charstring m_found_pattern; // Used in regex to verify that 'pointId' was not found before
                
                for (var integer v_counter := 0; v_counter < sizeof(p_tollContextPartitionLayout); v_counter := v_counter + 1) {
                    if (ischosen(p_tollContextPartitionLayout[v_counter].layoutDescription.areaPricingLayout)) {
                        var Layout.areaPricingLayout v_areaLayoutList := p_tollContextPartitionLayout[v_counter].layoutDescription.areaPricingLayout;
                        
                        // Parse AreaLayout list
                        for (var integer v_idx := 0; v_idx < sizeof(v_areaLayoutList); v_idx := v_idx + 1) {
                            // Parse RoadNetwork list
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_areaLayoutList[v_idx].roadNetworks); v_jdx := v_jdx + 1) {
                                // Parse RoadNetworkObjects list
                                v_pointIdFound := ";"; // Reset the found list
                                for (var integer v_kdx := 0; v_kdx < sizeof(v_areaLayoutList[v_idx].roadNetworks[v_jdx].roadNetworkObjects); v_kdx := v_kdx + 1) {
                                    if (ispresent(v_areaLayoutList[v_idx].roadNetworks[v_jdx].roadNetworkObjects[v_kdx].networkPoints)) {
                                        var RoadNetworkObject.networkPoints v_networkPoints := v_areaLayoutList[v_idx].roadNetworks[v_jdx].roadNetworkObjects[v_kdx].networkPoints;
                                        v_pointIdFound := ";"; // Reset found list
                                        for (var integer v_ldx := 0; v_ldx < sizeof(v_networkPoints); v_ldx := v_ldx + 1) {
                                            v_pointId := int2str(v_networkPoints[v_ldx].pointIdentifier);
                                            m_found_pattern := pattern "*({v_pointId})*";
                                            if (regexp(v_pointIdFound, m_found_pattern, 0) == v_pointId) {
                                                return false; // pointId exist at least 2 times, uniqueness is not verified
                                            }
                                            // pointId non found, add current pointId into the built list
                                            v_pointIdFound := v_pointIdFound & v_pointId & ";";
                                        } // End of 'for' statement
                                    } // ispresent
                                } // End of 'for' statement
                            } // End of 'for' statement
                        } // End of 'for' statement
                    }
                } // End of 'for' statement
                
                return true;
            } // End of function f_check_uniqueness_tollContextLayout_areaPricingLayout_pointId

            /**
             * @desc    This function verifies the uniqueness of link ID in AreaPricingLayout
             * @param   p_tollContextPartitionLayout TollContextPartitionLayouts list
             * @return  true on success, false otherwise
             * @verdict unchanged
             */
            function f_check_uniqueness_tollContextLayout_areaPricingLayout_linkId(
                                                                                   in template(value) TollContextPartitionLayouts p_tollContextPartitionLayout
            ) runs on EutComp return boolean {
                
                var charstring v_linkIdFound := ";"; // Used to build the list of the linkId already processed
                var charstring v_linkId; // linkId currently processed
                var template charstring m_found_pattern; // Used in regex to verify that 'linkId' was not found before
                
                for (var integer v_counter := 0; v_counter < sizeof(p_tollContextPartitionLayout); v_counter := v_counter + 1) {
                    if (ischosen(p_tollContextPartitionLayout[v_counter].layoutDescription.areaPricingLayout)) {
                        var Layout.areaPricingLayout v_areaLayoutList := p_tollContextPartitionLayout[v_counter].layoutDescription.areaPricingLayout;
                        
                        // Parse AreaLayout list
                        for (var integer v_idx := 0; v_idx < sizeof(v_areaLayoutList); v_idx := v_idx + 1) {
                            v_linkIdFound := ";"; // Reset found list
                            // Parse RoadNetwork list
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_areaLayoutList[v_idx].roadNetworks); v_jdx := v_jdx + 1) {
                                // Parse RoadNetworkObjects list
                                for (var integer v_kdx := 0; v_kdx < sizeof(v_areaLayoutList[v_idx].roadNetworks[v_jdx].roadNetworkObjects); v_kdx := v_kdx + 1) {
                                    v_linkId := int2str(v_areaLayoutList[v_idx].roadNetworks[v_jdx].roadNetworkObjects[v_kdx].tollPath.linkId);
                                    m_found_pattern := pattern "*({v_linkId})*";
                                    if (regexp(v_linkIdFound, m_found_pattern, 0) == v_linkId) {
                                        return false; // linkId exist at least 2 times, uniqueness is not verified
                                    }
                                    // linkId non found, add current linkId into the built list
                                    v_linkIdFound := v_linkIdFound & v_linkId & ";";
                                } // End of 'for' statement
                            } // End of 'for' statement
                        } // End of 'for' statement
                    }
                } // End of 'for' statement
                
                return true;
            } // End of function f_check_uniqueness_tollContextLayout_areaPricingLayout_linkId

            /**
             * @desc    This function verifies that each point (i.e. startPoint, endPoint, intermediatePoints) defined in each Link of TollContextLayout has defined pointIdentifier EX-OR pointCoordinates 
             * @param   p_tollContextPartitionLayout TollContextPartitionLayouts list
             * @return  true on success, false otherwise
             * @verdict unchanged
             */
            function f_check_uniqueness_tollContextLayout_areaPricingLayout_pointDescription_Link(
                                                                                                  in template(value) TollContextPartitionLayouts p_tollContextPartitionLayout
            ) runs on EutComp return boolean {
                
                for (var integer v_counter := 0; v_counter < sizeof(p_tollContextPartitionLayout); v_counter := v_counter + 1) {
                    if (ischosen(p_tollContextPartitionLayout[v_counter].layoutDescription.areaPricingLayout)) {
                        var Layout.areaPricingLayout v_areaLayoutList := p_tollContextPartitionLayout[v_counter].layoutDescription.areaPricingLayout;
                        
                        // Parse AreaLayout list
                        for (var integer v_idx := 0; v_idx < sizeof(v_areaLayoutList); v_idx := v_idx + 1) {
                            // Parse RoadNetwork list
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_areaLayoutList[v_idx].roadNetworks); v_jdx := v_jdx + 1) {
                                // Parse RoadNetworkObjects list
                                for (var integer v_kdx := 0; v_kdx < sizeof(v_areaLayoutList[v_idx].roadNetworks[v_jdx].roadNetworkObjects); v_kdx := v_kdx + 1) {
                                    var Link v_link := v_areaLayoutList[v_idx].roadNetworks[v_jdx].roadNetworkObjects[v_kdx].tollPath;
        
                                    if (f_check_point(v_link.startPoint) == false) {
                                        return false; // Both field of Point data structure are defined ==> conflict
                                    }
                                    if (f_check_point(v_link.endPoint) == false) {
                                        return false; // Both field of Point data structure are defined ==> conflict
                                    }
                                    if (ispresent(v_link.intermediatePoints)) {
                                        // Parse intermediatePoints
                                        for (var integer v_ldx := 0; v_ldx < sizeof(v_link.intermediatePoints); v_ldx := v_ldx + 1) {
                                            if (f_check_point(v_link.intermediatePoints[v_ldx]) == false) {
                                                return false; // Both field of Point data structure are defined ==> conflict
                                            }
                                        } // End of 'for' statement
                                    } // else ignore it
                                } // End of 'for' statement
                             } // End of 'for' statement
                         } // End of 'for' statement
                    }
                } // End of 'for' statement
                
                return true;
            } // End of function f_check_uniqueness_tollContextLayout_areaPricingLayout_pointDescription_Link

            /**
             * @desc    This function verifies that Point identified by Point ID in Link has been defined in Network Points
             * @param   p_tollContextPartitionLayout TollContextPartitionLayouts list
             * @return  true on success, false otherwise
             * @verdict unchanged
             */
            function f_check_uniqueness_tollContextLayout_areaPricingLayout_Link_pointID_usedPoints(
                                                                                                    in template(value) TollContextPartitionLayouts p_tollContextPartitionLayout
            ) runs on EutComp return boolean {
                
                for (var integer v_counter := 0; v_counter < sizeof(p_tollContextPartitionLayout); v_counter := v_counter + 1) {
                    if (ischosen(p_tollContextPartitionLayout[v_counter].layoutDescription.areaPricingLayout)) {
                        var Layout.areaPricingLayout v_areaLayoutList := p_tollContextPartitionLayout[v_counter].layoutDescription.areaPricingLayout;
                        
                        // Parse AreaLayout list
                        for (var integer v_idx := 0; v_idx < sizeof(v_areaLayoutList); v_idx := v_idx + 1) {
                            // Parse RoadNetwork list
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_areaLayoutList[v_idx].roadNetworks); v_jdx := v_jdx + 1) {
                                // Parse RoadNetworkObjects list
                                for (var integer v_kdx := 0; v_kdx < sizeof(v_areaLayoutList[v_idx].roadNetworks[v_jdx].roadNetworkObjects); v_kdx := v_kdx + 1) {
                                    var Link v_link := v_areaLayoutList[v_idx].roadNetworks[v_jdx].roadNetworkObjects[v_kdx].tollPath;
        
                                    if (not ispresent(v_areaLayoutList[v_idx].roadNetworks[v_jdx].roadNetworkObjects[v_kdx].networkPoints)) {
                                        if (ischosen(v_link.startPoint.pointIdentifier)) {
                                            return false; // PointID is defined with an empty list of PointIDs
                                        }
                                        if (ischosen(v_link.endPoint.pointIdentifier)) {
                                            return false; // PointID is defined with an empty list of PointIDs
                                        }
                                        if (ispresent(v_link.intermediatePoints)) {
                                            // Parse intermediatePoints
                                            for (var integer v_ldx := 0; v_ldx < sizeof(v_link.intermediatePoints); v_ldx := v_ldx + 1) {
                                                if (ischosen(v_link.intermediatePoints[v_ldx].pointIdentifier)) {
                                                    return false; // PointID is defined with an empty list of PointIDs
                                                }
                                            } // End of 'for' statement
                                        } // else ignore it
                                    } else { // A list of pointID is defined
                                        var charstring v_pointIdFound := f_build_PointId_RoadNetworkObject_NetworkPoints(v_areaLayoutList[v_idx].roadNetworks[v_jdx].roadNetworkObjects[v_kdx].networkPoints); // Build the list of the pointId declared in networkPoints
                                        var charstring v_pointId := "";
                                        var template charstring m_found_pattern; // Used in regex to verify that 'pointId' was not found before
                                        
                                        if (ischosen(v_link.startPoint.pointIdentifier)) {
                                            v_pointId := int2str(v_link.startPoint.pointIdentifier);
                                            m_found_pattern := pattern "*({v_pointId})*";
                                            if (regexp(v_pointIdFound, m_found_pattern, 0) != v_pointId) {
                                                return false; // pointId does not exist
                                            }
                                        }
                                        if (ischosen(v_link.endPoint.pointIdentifier)) {
                                            v_pointId := int2str(v_link.endPoint.pointIdentifier);
                                            m_found_pattern := pattern "*({v_pointId})*";
                                            if (regexp(v_pointIdFound, m_found_pattern, 0) != v_pointId) {
                                                return false; // pointId does not exist
                                            }
                                        }
                                        if (ispresent(v_link.intermediatePoints)) {
                                            // Parse intermediatePoints
                                            for (var integer v_ldx := 0; v_ldx < sizeof(v_link.intermediatePoints); v_ldx := v_ldx + 1) {
                                                if (ischosen(v_link.intermediatePoints[v_jdx].pointIdentifier)) {
                                                    v_pointId := int2str(v_link.intermediatePoints[v_ldx].pointIdentifier);
                                                    m_found_pattern := pattern "*({v_pointId})*";
                                                    if (regexp(v_pointIdFound, m_found_pattern, 0) != v_pointId) {
                                                        return false; // pointId does not exist
                                                    }
                                                }
                                            } // End of 'for' statement
                                        } // else ignore it
                                    }
                                } // End of 'for' statement
                            } // End of 'for' statement
                        } // End of 'for' statement
                    }
                } // End of 'for' statement
                
                return true;
            } // End of function f_check_uniqueness_tollContextLayout_areaPricingLayout_Link_pointID_networkPoints

            /**
             * @desc    This function verifies that each point (i.e. startPoint, endPoint, intermediatePoints) defined in each SupportingPoint of TollContextLayout has defined pointIdentifier EX-OR pointCoordinates
             * @param   p_tollContextPartitionLayout TollContextPartitionLayouts list
             * @return  true on success, false otherwise
             * @verdict unchanged
             */
            function f_check_uniqueness_tollContextLayout_areaPricingLayout_pointDescription_SupportingPoint(
                                                                                                             in template(value) TollContextPartitionLayouts p_tollContextPartitionLayout
            ) runs on EutComp return boolean {
                // p_areaLayoutList shall not be omit
                
                for (var integer v_counter := 0; v_counter < sizeof(p_tollContextPartitionLayout); v_counter := v_counter + 1) {
                    if (ischosen(p_tollContextPartitionLayout[v_counter].layoutDescription.areaPricingLayout)) {
                        var Layout.areaPricingLayout v_areaLayoutList := p_tollContextPartitionLayout[v_counter].layoutDescription.areaPricingLayout;
                        
                        // Parse AreaLayout list
                        for (var integer v_idx := 0; v_idx < sizeof(v_areaLayoutList); v_idx := v_idx + 1) {
                            // Parse RoadNetwork list
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_areaLayoutList[v_idx].roadNetworks); v_jdx := v_jdx + 1) {
                                // Parse RoadNetworkObjects list
                                for (var integer v_kdx := 0; v_kdx < sizeof(v_areaLayoutList[v_idx].roadNetworks[v_jdx].roadNetworkObjects); v_kdx := v_kdx + 1) {
                                    if (ispresent(v_areaLayoutList[v_idx].roadNetworks[v_jdx].roadNetworkObjects[v_kdx].supportingInformation)) {
                                        for (var integer v_ldx := 0; v_ldx < sizeof(v_areaLayoutList[v_idx].roadNetworks[v_jdx].roadNetworkObjects[v_kdx].supportingInformation); v_ldx := v_ldx + 1) {
                                            var SupportingPoint v_supportingPoint := v_areaLayoutList[v_idx].roadNetworks[v_jdx].roadNetworkObjects[v_kdx].supportingInformation[v_ldx];
                                            if (ispresent(v_supportingPoint.supportPoint)) {
                                                if (f_check_point(v_supportingPoint.supportPoint) == false) {
                                                    return false; // Both field of Point data structure are defined ==> conflict
                                                }
                                            }
                                        } // End of 'for' statement
                                    } // else continue
                                } // End of 'for' statement
                            } // End of 'for' statement
                        } // End of 'for' statement
                    }
                } // End of 'for' statement
                
                return true;
            } // End of function f_check_uniqueness_tollContextLayout_areaPricingLayout_pointDescription_SupportingPoint

            /**
             * @desc    This function verifies that Point identified by Point ID in SupportingPoint has been defined in Network Points
             * @param   p_tollContextPartitionLayout TollContextPartitionLayouts list
             * @return  true on success, false otherwise
             * @verdict unchanged
             */
            function f_check_uniqueness_tollContextLayout_areaPricingLayout_SupportingPoint_pointID_networkPoints(
                                                                                                                  in template(value) TollContextPartitionLayouts p_tollContextPartitionLayout
            ) runs on EutComp return boolean {
                
                for (var integer v_counter := 0; v_counter < sizeof(p_tollContextPartitionLayout); v_counter := v_counter + 1) {
                    if (ischosen(p_tollContextPartitionLayout[v_counter].layoutDescription.areaPricingLayout)) {
                        var Layout.areaPricingLayout v_areaLayoutList := p_tollContextPartitionLayout[v_counter].layoutDescription.areaPricingLayout;
                        
                        // Parse AreaLayout list
                        for (var integer v_idx := 0; v_idx < sizeof(v_areaLayoutList); v_idx := v_idx + 1) {
                            // Parse RoadNetwork list
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_areaLayoutList[v_idx].roadNetworks); v_jdx := v_jdx + 1) {
                                // Parse RoadNetworkObjects list
                                for (var integer v_kdx := 0; v_kdx < sizeof(v_areaLayoutList[v_idx].roadNetworks[v_jdx].roadNetworkObjects); v_kdx := v_kdx + 1) {
                                    // Parse SupportingInformation list
                                    for (var integer v_ldx := 0; v_ldx < sizeof(v_areaLayoutList[v_idx].roadNetworks[v_jdx].roadNetworkObjects[v_kdx].supportingInformation); v_ldx := v_ldx + 1) {
                                        var SupportingPoint v_supportingPoint := v_areaLayoutList[v_idx].roadNetworks[v_jdx].roadNetworkObjects[v_kdx].supportingInformation[v_ldx];
                                        if (ispresent(v_supportingPoint.supportPoint)) {
                                            if (not ispresent(v_areaLayoutList[v_idx].roadNetworks[v_jdx].roadNetworkObjects[v_kdx].networkPoints)) { // No pointID defined
                                                if (ischosen(v_supportingPoint.supportPoint.pointIdentifier)) {
                                                    return false; // PointID is defined with an empty list of PointIDs
                                                }
                                            } else { // A list of pointID is defined
                                                var charstring v_pointIdFound := f_build_PointId_RoadNetworkObject_NetworkPoints(v_areaLayoutList[v_idx].roadNetworks[v_jdx].roadNetworkObjects[v_kdx].networkPoints); // Build the list of the pointId declared in networkPoints
                                                var charstring v_pointId := "";
                                                var template charstring m_found_pattern; // Used in regex to verify that 'pointId' was not found before
                                                
                                                if (ischosen(v_supportingPoint.supportPoint.pointIdentifier)) {
                                                    v_pointId := int2str(v_supportingPoint.supportPoint.pointIdentifier);
                                                    m_found_pattern := pattern "*({v_pointId})*";
                                                    if (regexp(v_pointIdFound, m_found_pattern, 0) != v_pointId) {
                                                        return false; // pointId does not exist
                                                    }
                                                }
                                            }
                                        } // ispresent(v_supportingPoint.supportPoint)
                                    } // End of 'for' statement
                                } // else continue
                            } // End of 'for' statement
                        } // End of 'for' statement
                    }
                } // End of 'for' statement
                
                return true;
            } // End of function f_check_uniqueness_tollContextLayout_areaPricingLayout_SupportingPoint_pointID_networkPoints

        } // End of group Area_Pricing_Layout

        /**
         * @desc    Functions for TCs related to Cordon Pricing Layout
         * @see     [17575-3:2016], 8.3.4.3. Data element cordonLayout
         */
        group Cordon_Pricing_Layout {
            
            /**
             * @desc    This function verifies the uniqueness of cordon segment ID in CordonLayout.cordonBorderPolygon
             * @param   p_tollContextPartitionLayout TollContextPartitionLayouts list
             * @return  true on success, false otherwise
             * @verdict unchanged
             */
            function f_check_uniqueness_tollContextLayout_cordonPricingLayout_cordonSegmentId(
                                                                                              in template(value) TollContextPartitionLayouts p_tollContextPartitionLayout
            ) runs on EutComp return boolean {
                
                var charstring v_cordonSegmentIdFound := ";"; // Used to build the list of the cordonSegmentId already processed
                var charstring v_cordonSegmentId; // cordonSegmentId currently processed
                var template charstring m_found_pattern; // Used in regex to verify that 'cordonSegmentId' was not found before
                
                for (var integer v_counter := 0; v_counter < sizeof(p_tollContextPartitionLayout); v_counter := v_counter + 1) {
                    if (ischosen(p_tollContextPartitionLayout[v_counter].layoutDescription.cordonPricingLayout)) {
                        var Layout.cordonPricingLayout v_cordonLayoutList := p_tollContextPartitionLayout[v_counter].layoutDescription.cordonPricingLayout;
                        
                        // Parse CordonLayout list
                        for (var integer v_idx := 0; v_idx < sizeof(v_cordonLayoutList); v_idx := v_idx + 1) {
                            // Parse CordonBorderSegment list
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_cordonLayoutList[v_idx].cordonBorderPolygon); v_jdx := v_jdx + 1) {
                                v_cordonSegmentId := int2str(v_cordonLayoutList[v_idx].cordonBorderPolygon[v_jdx].cordonSegmentId);
                                m_found_pattern := pattern "*({v_cordonSegmentId})*";
                                if (regexp(v_cordonSegmentIdFound, m_found_pattern, 0) == v_cordonSegmentId) {
                                    return false; // cordonSegmentId exist at least 2 times, uniqueness is not verified
                                }
                                // cordonSegmentId non found, add current cordonSegmentId into the built list
                                v_cordonSegmentIdFound := v_cordonSegmentIdFound & v_cordonSegmentId & ";";
                            } // End of 'for' statement
                        } // End of 'for' statement
                    }
                } // End of 'for' statement 
                
                return true;
            } // End of function f_check_uniqueness_tollContextLayout_cordonPricingLayout_cordonSegmentId

            /**
             * @desc    This function verifies the uniqueness of cordon ID in CordonLayout
             * @param   p_tollContextPartitionLayout TollContextPartitionLayouts list
             * @return  true on success, false otherwise
             * @verdict unchanged
             */
            function f_check_uniqueness_tollContextLayout_cordonPricingLayout_cordonId(
                                                                                       in template(value) TollContextPartitionLayouts p_tollContextPartitionLayout
            ) runs on EutComp return boolean {
                
                var charstring v_cordonIdFound := ";"; // Used to build the list of the cordonId already processed
                var charstring v_cordonId; // cordonId currently processed
                var template charstring m_found_pattern; // Used in regex to verify that 'cordonId' was not found before
                
                for (var integer v_counter := 0; v_counter < sizeof(p_tollContextPartitionLayout); v_counter := v_counter + 1) {
                    if (ischosen(p_tollContextPartitionLayout[v_counter].layoutDescription.cordonPricingLayout)) {
                        var Layout.cordonPricingLayout v_cordonLayoutList := p_tollContextPartitionLayout[v_counter].layoutDescription.cordonPricingLayout;
                        
                        // Parse CordonLayout list
                        for (var integer v_idx := 0; v_idx < sizeof(v_cordonLayoutList); v_idx := v_idx + 1) {
                            v_cordonId := int2str(v_cordonLayoutList[v_idx].cordonId);
                            m_found_pattern := pattern "*({v_cordonId})*";
                            if (regexp(v_cordonIdFound, m_found_pattern, 0) == v_cordonId) {
                                return false; // cordonId exist at least 2 times, uniqueness is not verified
                            }
                            // cordonId non found, add current cordonId into the built list
                            v_cordonIdFound := v_cordonIdFound & v_cordonId & ";";
                        } // End of 'for' statement
                    }
                } // End of 'for' statement 
                
                return true;
            } // End of function f_check_uniqueness_tollContextLayout_cordonPricingLayout_cordonId
            
            /**
             * @desc    This function verifies that Applicable Time Classes for Cordon Layout are present in Time Class Definition (Cordon Entry Locations)
             * @param   p_tollContextPartitionLayout TollContextPartitionLayouts list
             * @param   p_timeclasses TimeClasslist, it could be null
             * @return  true on success, false otherwise
             * @remark  If applicableTimeClasses = , result  of the verification for particular cordonEntryLocations is OK
             * @verdict unchanged
             */
            function f_check_uniqueness_tollContextLayout_cordonPricingLayout_cordonEntryLocation_applicableTimeClasses(
                                                                                                                        in template(value) TollContextPartitionLayouts p_tollContextPartitionLayout,
                                                                                                                        in TimeClassDefinition.timeClasses p_timeclasses
            ) runs on EutComp return boolean {
                
                if (p_timeclasses == null) {
                    // applicableTimeClasses shall be omit
                    
                    for (var integer v_counter := 0; v_counter < sizeof(p_tollContextPartitionLayout); v_counter := v_counter + 1) {
                        if (ischosen(p_tollContextPartitionLayout[v_counter].layoutDescription.cordonPricingLayout)) {
                            var Layout.cordonPricingLayout v_cordonLayoutList := p_tollContextPartitionLayout[v_counter].layoutDescription.cordonPricingLayout;
                            
                            // Parse CordonLayout list
                            for (var integer v_idx := 0; v_idx < sizeof(v_cordonLayoutList); v_idx := v_idx + 1) {
                                // Parse CordonBorderSegment list
                                for (var integer v_jdx := 0; v_jdx < sizeof(v_cordonLayoutList[v_idx].cordonBorderPolygon); v_jdx := v_jdx + 1) {
                                    if (ispresent(v_cordonLayoutList[v_idx].cordonBorderPolygon[v_jdx].cordonEntryLocation)) {
                                        return false; // Error
                                    }
                                } // End of 'for' statement
                            } // End of 'for' statement
                        }
                    } // End of 'for' statement
                } else {
                    var charstring v_timeClassId; // timeClassId currently processed
                    var template charstring m_found_pattern; // Used in regex to verify that 'timeClassId' is in the built list
                    // Build the list of Time Class Identifiers
                    var charstring v_timeClassIds := f_build_timeId_timeClasses(p_timeclasses);
                    
                    for (var integer v_counter := 0; v_counter < sizeof(p_tollContextPartitionLayout); v_counter := v_counter + 1) {
                        if (ischosen(p_tollContextPartitionLayout[v_counter].layoutDescription.cordonPricingLayout)) {
                            var Layout.cordonPricingLayout v_cordonLayoutList := p_tollContextPartitionLayout[v_counter].layoutDescription.cordonPricingLayout;
                            
                            // Parse CordonLayout list
                            for (var integer v_idx := 0; v_idx < sizeof(v_cordonLayoutList); v_idx := v_idx + 1) {
                                // Parse CordonBorderSegment list
                                for (var integer v_jdx := 0; v_jdx < sizeof(v_cordonLayoutList[v_idx].cordonBorderPolygon); v_jdx := v_jdx + 1) {
                                    if (ispresent(v_cordonLayoutList[v_idx].cordonBorderPolygon[v_jdx].cordonEntryLocation)) {
                                        if (ispresent(v_cordonLayoutList[v_idx].cordonBorderPolygon[v_jdx].cordonEntryLocation.applicableTimeClasses)) {
                                            // Parse TimeClassId list
                                            for (var integer v_kdx := 0; v_kdx < sizeof(v_cordonLayoutList[v_idx].cordonBorderPolygon[v_jdx].cordonEntryLocation.applicableTimeClasses); v_kdx := v_kdx + 1) {
                                                // Verify that timeClassId is specified in current applicableTimeClasses is defined in p_timeclasses
                                                v_timeClassId := int2str(v_cordonLayoutList[v_idx].cordonBorderPolygon[v_jdx].cordonEntryLocation.applicableTimeClasses[v_kdx]);
                                                m_found_pattern := pattern "*({v_timeClassId})*";
                                                if (regexp(v_timeClassIds, m_found_pattern, 0) != v_timeClassId) {
                                                    return false; // timeClassId is not specified in current applicableTimeClasses is defined in p_timeclasses
                                                }
                                            } // End of 'for' statement
                                        } // ispresent
                                        // else continue - Note: If applicableTimeClasses = , result  of the verification for particular cordonEntryLocation is OK
                                    } // End of 'for' statement
                                } // ispresent
                            } // End of 'for' statement
                        }
                    } // End of 'for' statement
                }
                
                return true;
            } // End of function f_check_uniqueness_tollContextLayout_cordonPricingLayout_cordonEntryLocation_applicableTimeClasses
            
            /**
             * @desc    This function verifies that Applicable Time Classes for Cordon Layout are present in Time Class Definition (Cordon Exit Locations)
             * @param   p_timeclasses TimeClasslist, it could be null
             * @return  true on success, false otherwise
             * @remark  If applicableTimeClasses = , result  of the verification for particular cordonExitLocations is OK
             * @verdict unchanged
             */
            function f_check_uniqueness_tollContextLayout_cordonPricingLayout_cordonExitLocation_applicableTimeClasses(
                                                                                                                       in template(value) TollContextPartitionLayouts p_tollContextPartitionLayout,
                                                                                                                       in TimeClassDefinition.timeClasses p_timeclasses
            ) runs on EutComp return boolean {
                
                if (p_timeclasses == null) {
                    // applicableTimeClasses shall be omit
                    
                    for (var integer v_counter := 0; v_counter < sizeof(p_tollContextPartitionLayout); v_counter := v_counter + 1) {
                        if (ischosen(p_tollContextPartitionLayout[v_counter].layoutDescription.cordonPricingLayout)) {
                            var Layout.cordonPricingLayout v_cordonLayoutList := p_tollContextPartitionLayout[v_counter].layoutDescription.cordonPricingLayout;
                            
                            // Parse CordonLayout list
                            for (var integer v_idx := 0; v_idx < sizeof(v_cordonLayoutList); v_idx := v_idx + 1) {
                                // Parse CordonBorderSegment list
                                for (var integer v_jdx := 0; v_jdx < sizeof(v_cordonLayoutList[v_idx].cordonBorderPolygon); v_jdx := v_jdx + 1) {
                                    if (ispresent(v_cordonLayoutList[v_idx].cordonBorderPolygon[v_jdx].cordonExitLocation)) {
                                        return false; // Error
                                    }
                                } // End of 'for' statement
                            } // End of 'for' statement
                        }
                    } // End of 'for' statement
                } else {
                    var charstring v_timeClassId; // timeClassId currently processed
                    var template charstring m_found_pattern; // Used in regex to verify that 'timeClassId' is in the built list
                    // Build the list of Time Class Identifiers
                    var charstring v_timeClassIds := f_build_timeId_timeClasses(p_timeclasses);
                    
                    for (var integer v_counter := 0; v_counter < sizeof(p_tollContextPartitionLayout); v_counter := v_counter + 1) {
                        if (ischosen(p_tollContextPartitionLayout[v_counter].layoutDescription.cordonPricingLayout)) {
                            var Layout.cordonPricingLayout v_cordonLayoutList := p_tollContextPartitionLayout[v_counter].layoutDescription.cordonPricingLayout;
                            
                            // Parse CordonLayout list
                            for (var integer v_idx := 0; v_idx < sizeof(v_cordonLayoutList); v_idx := v_idx + 1) {
                                // Parse CordonBorderSegment list
                                for (var integer v_jdx := 0; v_jdx < sizeof(v_cordonLayoutList[v_idx].cordonBorderPolygon); v_jdx := v_jdx + 1) {
                                    if (ispresent(v_cordonLayoutList[v_idx].cordonBorderPolygon[v_jdx].cordonExitLocation)) {
                                        if (ispresent(v_cordonLayoutList[v_idx].cordonBorderPolygon[v_jdx].cordonExitLocation.applicableTimeClasses)) {
                                            // Parse TimeClassId list
                                            // Parse TimeClassId list
                                            for (var integer v_kdx := 0; v_kdx < sizeof(v_cordonLayoutList[v_idx].cordonBorderPolygon[v_jdx].cordonExitLocation.applicableTimeClasses); v_kdx := v_kdx + 1) {
                                                // Verify that timeClassId is specified in current applicableTimeClasses is defined in p_timeclasses
                                                v_timeClassId := int2str(v_cordonLayoutList[v_idx].cordonBorderPolygon[v_jdx].cordonExitLocation.applicableTimeClasses[v_kdx]);
                                                m_found_pattern := pattern "*({v_timeClassId})*";
                                                if (regexp(v_timeClassIds, m_found_pattern, 0) != v_timeClassId) {
                                                    return false; // timeClassId is not specified in current applicableTimeClasses is defined in p_timeclasses
                                                }
                                            } // End of 'for' statement
                                        } // ispresent
                                        // else continue - Note: If applicableTimeClasses = , result  of the verification for particular cordonExitLocation is OK
                                    } // End of 'for' statement
                                } // ispresent
                            } // End of 'for' statement
                        }
                    } // End of 'for' statement
                }
                
                return true;
            } // End of function f_check_uniqueness_tollContextLayout_cordonPricingLayout_cordonExitLocation_applicableTimeClasses
            
        } // End of group Cordon_Pricing_Layout
        
    } // End of group Validation

    /**
     * @desc    Comparition functions group
     */
    group Comparition {

        /**
         * @desc    This function compares all the data elements in the both provided lists, checking versionning when data element value differs
         * @param   p_body1 ADU.Body message containing the list to compare
         * @param   p_body2 ADU.Body message containing the list to compare
         * @return  ture on success, false if versionning mismatch is found
         * @verdict unchanged
         */
        function f_compareDataElements(
                                       in Iso17575_3AduBody p_body1, 
                                       in Iso17575_3AduBody p_body2
        ) runs on EutComp return boolean {

            // Parse data elements
            if(ispresent(p_body1.tollContextOverview) and ispresent(p_body2.tollContextOverview)) {
                // Check if data element are identicals
                if (match(p_body2.tollContextOverview, valueof(p_body1.tollContextOverview)) == false) {
                    // Check version
                    if (f_compareVersion(p_body1.tollContextOverview.unsigned_data.tollContextOverviewVersion, p_body2.tollContextOverview.unsigned_data.tollContextOverviewVersion) != 1) { // v2 > v1?
                        return false;
                    }
                }
            } // End of 'if' statement

            if(ispresent(p_body1.tariffTable) and ispresent(p_body2.tariffTable)) {
                // Check if data element are identicals
                if (match(p_body2.tariffTable, valueof(p_body1.tariffTable)) == false) {
                    // Check version
                    if (
                            f_compareVersion(
                                p_body1.tariffTable.unsigned_data[0].tariffTableVersion, 
                                p_body2.tariffTable.unsigned_data[0].tariffTableVersion
                            ) != 1
                    ) { // v2 > v1?
                        return false;
                    }
                }
            } // End of 'if' statement

            if(ispresent(p_body1.tariffClassDefinition) and ispresent(p_body2.tariffClassDefinition)) {
                // Check if data element are identicals
                if (match(p_body2.tariffClassDefinition, valueof(p_body1.tariffClassDefinition)) == false) {
                    // Check version
                    if (f_compareVersion(p_body1.tariffClassDefinition.unsigned_data.tariffClassDefinitionVersion, p_body2.tariffClassDefinition.unsigned_data.tariffClassDefinitionVersion) != 1) { // v2 > v1?
                        return false;
                    }
                }
            } // End of 'if' statement

            if(ispresent(p_body1.localVehicleClassDefinition) and ispresent(p_body2.localVehicleClassDefinition)) {
                // Check if data element are identicals
                if (match(p_body2.localVehicleClassDefinition, valueof(p_body1.localVehicleClassDefinition)) == false) {
                    // Check version
                    if (f_compareVersion(p_body1.localVehicleClassDefinition.unsigned_data.localVehicleClassVersion, p_body2.localVehicleClassDefinition.unsigned_data.localVehicleClassVersion) != 1) { // v2 > v1?
                        return false;
                    }
                }
            } // End of 'if' statement

            if(ispresent(p_body1.timeClassDefinition) and ispresent(p_body2.timeClassDefinition)) {
                // Check if data element are identicals
                if (match(p_body2.timeClassDefinition, valueof(p_body1.timeClassDefinition)) == false) {
                    // Check version
                    if (f_compareVersion(p_body1.timeClassDefinition.unsigned_data.timeClassDefinitionVersion, p_body2.timeClassDefinition.unsigned_data.timeClassDefinitionVersion) != 1) { // v2 > v1?
                        return false;
                    }
                }
            } // End of 'if' statement

            if(ispresent(p_body1.userClassDefinition) and ispresent(p_body2.userClassDefinition)) {
                // Check if data element are identicals
                if (match(p_body2.userClassDefinition, valueof(p_body1.userClassDefinition)) == false) {
                    // Check version
                    if (f_compareVersion(p_body1.userClassDefinition.unsigned_data.userClassDefinitionVersion, p_body2.userClassDefinition.unsigned_data.userClassDefinitionVersion) != 1) { // v2 > v1?
                        return false;
                    }
                }
            } // End of 'if' statement

            if(ispresent(p_body1.tollContextLayout) and ispresent(p_body2.tollContextLayout)) {
                // Check if data element are identicals
                if (match(p_body2.tollContextLayout, valueof(p_body1.tollContextLayout)) == false) {
                    // Check version
                    if (f_compareVersion(p_body1.tollContextLayout.unsigned_data[0].tollContextPartitionVersion, p_body2.tollContextLayout.unsigned_data[0].tollContextPartitionVersion) != 1) { // v2 > v1?
                        return false;
                    }
                }
            } // End of 'if' statement

            if(ispresent(p_body1.chargeReportingEvents) and ispresent(p_body2.chargeReportingEvents)) {
                // Check if data element are identicals
                if (match(p_body2.chargeReportingEvents, valueof(p_body1.chargeReportingEvents)) == false) {
                    // Check version
                    if (f_compareVersion(p_body1.chargeReportingEvents.unsigned_data[0].chargeReportingEventsVersion, p_body2.chargeReportingEvents.unsigned_data[0].chargeReportingEventsVersion) != 1) { // v2 > v1?
                        return false;
                    }
                }
            } // End of 'if' statement

            if(ispresent(p_body1.chargeReportConfiguration) and ispresent(p_body2.chargeReportConfiguration)) {
                // Check if data element are identicals
                if (match(p_body2.chargeReportConfiguration, valueof(p_body1.chargeReportConfiguration)) == false) {
                    // Check version
                    if (
                        f_compareVersion(
                            p_body1.chargeReportConfiguration.unsigned_data[0].chargeReportConfigurationVersion, 
                            p_body2.chargeReportConfiguration.unsigned_data[0].chargeReportConfigurationVersion) != 1) { // v2 > v1?
                        return false;
                    }
                }
            } // End of 'if' statement

            return true;
        } // End of function f_compareDataElements

        /**
         * @desc    This function compares 2 Time values
         * @param   p_beginOfTime First value to compare
         * @param   p_endOfTime Second value to compare
         * @return  -1 if p_beginOfTime < p_endOfTime, 0 if p_beginOfTime == p_endOfTime and +1 if p_beginOfTime > p_endOfTime
         * @verdict unchanged on success, fail on priocessing error
         */
        function f_compareTime(
                               in Time p_beginOfTime, 
                               in Time p_endOfTime
        ) runs on EutComp return integer {
            if (p_beginOfTime.hours < p_endOfTime.hours) {
                return -1;
            } else if (p_beginOfTime.hours > p_endOfTime.hours) {
                return 1;
            } else if (p_beginOfTime.mins < p_endOfTime.mins) {
                return -1;
            } else if (p_beginOfTime.mins > p_endOfTime.mins) {
                return 1;
            }

            return 0;
        } // End of function f_compareTime
    } // End of group Comparition
    
    group External_functions {
        
        /**
         * @desc    This function verifies that polygon points are defined in a way that the connections between the points do not intersect
         * @param   p_polygon The polygon to check
         * @return  true on success, false otherwise
         * @verdict unchanged on success, fail on priocessing error
         */
        external function fx_isPolygonPointsIntersect(in Polygon p_polygon) return boolean;
        
    } // End of group External_functions
    
    group Internal_functions {
        /**
         * @desc    This function builds the overlapped groups based on at least one criterion
         * @param   p_locvehclassList The list of the LocalVehicleClass values
         * @return  The built group
         * @verdict unchanged
         */
        function f_Build_localVehicleClass_groups(
                                                  in LocalVehicleClassDefinition.localVehicleClasses p_locvehclassList
        ) runs on EutComp return LocalVehicleClassesGroups {
            var LocalVehicleClassesGroups v_groups := { }; // Group localVehicleClasses that overlap at least with one criterion
            var boolean v_createNewGroup; // Used to indicate if a new group shall be created

            // Parse all LocalVehicleClass items in the list p_locvehclassList
            for (var integer v_idx := 0; v_idx < sizeof(p_locvehclassList); v_idx := v_idx + 1) {
                v_createNewGroup := true; // Default value
                // Parse each group
                for (var integer v_igroup := 0; v_igroup < sizeof(v_groups); v_igroup := v_igroup + 1) {
                    if (f_isItemInLocalVehicleClasseGroups(p_locvehclassList[v_idx], v_groups[v_igroup])) {
                        // An ovelapp was found, add current LocalVehicleClass item into the current group...
                        v_groups[v_igroup][sizeof(v_groups[v_igroup])] := p_locvehclassList[v_idx];
                        v_createNewGroup := false; // Creation is not required
                        break; // ...and exit from the loop
                    }
                } // End of 'for' statement
                if (v_createNewGroup == true) {
                    // Create a new group with the current LocalVehicleClass item
                    v_groups[sizeof(v_groups)] := { p_locvehclassList[v_idx] };
                }
            } // End of 'for' statement

            return v_groups; // Error
        } // End of function f_Build_localVehicleClass_groups

        /**
         * @desc    This function searches for overlap based on one criterion
         * @param   p_locvehclass The LocalVehicleClass item to process
         * @param   p_classInGroup The list of group localVehicleClasses that overlap at least with one criterion
         * @return  true if p_locvehclass value overlaps one of the LocalVehicleClass item in a group, false otherwise
         * @verdict unchanged
         */
        function f_isItemInLocalVehicleClasseGroups(
                                                    in LocalVehicleClass p_locvehclass, 
                                                    in LocalVehicleClassGroupItem p_classInGroup
        ) runs on EutComp return boolean {

            for (var integer v_idxLocalVehicleClass := 0; v_idxLocalVehicleClass < sizeof(p_classInGroup); v_idxLocalVehicleClass := v_idxLocalVehicleClass + 1) {
                var LocalVehicleClass v_groupItem := p_classInGroup[v_idxLocalVehicleClass];
                // Check nominalElements

                // Check ordinalElements
                if (ispresent(p_locvehclass.ordinalElements) and ispresent(v_groupItem.ordinalElements)) {
                    // 1. vehicleLengthOverall
                    if (ispresent(p_locvehclass.ordinalElements.vehicleLengthOverall) and ispresent(v_groupItem.ordinalElements.vehicleLengthOverall)) {
                        for (var integer v_idx := 0; v_idx < sizeof(p_locvehclass.ordinalElements.vehicleLengthOverall); v_idx := v_idx + 1) {
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_groupItem.ordinalElements.vehicleLengthOverall); v_jdx := v_jdx + 1) {
                                if (not ((v_groupItem.ordinalElements.vehicleLengthOverall[v_jdx].lowerLimit < p_locvehclass.ordinalElements.vehicleLengthOverall[v_idx].lowerLimit) or (v_groupItem.ordinalElements.vehicleLengthOverall[v_jdx].upperLimit > p_locvehclass.ordinalElements.vehicleLengthOverall[v_idx].upperLimit))) {
                                    // There is an overlapp
                                    return true;
                                }
                            }
                        }
                    }
                    // 2. vehicleLengthOverall
                    if (ispresent(p_locvehclass.ordinalElements.vehicleLengthOverall) and ispresent(v_groupItem.ordinalElements.vehicleLengthOverall)) {
                        for (var integer v_idx := 0; v_idx < sizeof(p_locvehclass.ordinalElements.vehicleLengthOverall); v_idx := v_idx + 1) {
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_groupItem.ordinalElements.vehicleLengthOverall); v_jdx := v_jdx + 1) {
                                if (not ((v_groupItem.ordinalElements.vehicleLengthOverall[v_jdx].lowerLimit < p_locvehclass.ordinalElements.vehicleLengthOverall[v_idx].lowerLimit) or (v_groupItem.ordinalElements.vehicleLengthOverall[v_jdx].upperLimit > p_locvehclass.ordinalElements.vehicleLengthOverall[v_idx].upperLimit))) {
                                    // There is an overlapp
                                    return true;
                                }
                            }
                        }
                    }
                    // 3. vehicleWidthOverall
                    if (ispresent(p_locvehclass.ordinalElements.vehicleWidthOverall) and ispresent(v_groupItem.ordinalElements.vehicleWidthOverall)) {
                        for (var integer v_idx := 0; v_idx < sizeof(p_locvehclass.ordinalElements.vehicleWidthOverall); v_idx := v_idx + 1) {
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_groupItem.ordinalElements.vehicleWidthOverall); v_jdx := v_jdx + 1) {
                                if (not ((v_groupItem.ordinalElements.vehicleWidthOverall[v_jdx].lowerLimit < p_locvehclass.ordinalElements.vehicleWidthOverall[v_idx].lowerLimit) or (v_groupItem.ordinalElements.vehicleWidthOverall[v_jdx].upperLimit > p_locvehclass.ordinalElements.vehicleWidthOverall[v_idx].upperLimit))) {
                                    // There is an overlapp
                                    return true;
                                }
                            }
                        }
                    }
                    // 4. vehicleFirstAxleHeight
                    if (ispresent(p_locvehclass.ordinalElements.vehicleFirstAxleHeight) and ispresent(v_groupItem.ordinalElements.vehicleFirstAxleHeight)) {
                        for (var integer v_idx := 0; v_idx < sizeof(p_locvehclass.ordinalElements.vehicleFirstAxleHeight); v_idx := v_idx + 1) {
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_groupItem.ordinalElements.vehicleFirstAxleHeight); v_jdx := v_jdx + 1) {
                                if (not ((v_groupItem.ordinalElements.vehicleFirstAxleHeight[v_jdx].lowerLimit < p_locvehclass.ordinalElements.vehicleFirstAxleHeight[v_idx].lowerLimit) or (v_groupItem.ordinalElements.vehicleFirstAxleHeight[v_jdx].upperLimit > p_locvehclass.ordinalElements.vehicleFirstAxleHeight[v_idx].upperLimit))) {
                                    // There is an overlapp
                                    return true;
                                }
                            }
                        }
                    }
                    // 5. vehicleAxlesNumber
                    if (ispresent(p_locvehclass.ordinalElements.vehicleTractorAxlesNumber) and ispresent(v_groupItem.ordinalElements.vehicleTractorAxlesNumber)) {
                        for (var integer v_idx := 0; v_idx < sizeof(p_locvehclass.ordinalElements.vehicleTractorAxlesNumber); v_idx := v_idx + 1) {
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_groupItem.ordinalElements.vehicleTractorAxlesNumber); v_jdx := v_jdx + 1) {
                                if (not ((v_groupItem.ordinalElements.vehicleTractorAxlesNumber[v_jdx].lowerLimit < p_locvehclass.ordinalElements.vehicleTractorAxlesNumber[v_idx].lowerLimit) or (v_groupItem.ordinalElements.vehicleTractorAxlesNumber[v_jdx].upperLimit > p_locvehclass.ordinalElements.vehicleTractorAxlesNumber[v_idx].upperLimit))) {
                                    // There is an overlapp
                                    return true;
                                }
                            }
                        }
                    }
                    if (ispresent(p_locvehclass.ordinalElements.vehicleTrailerAxlesNumber) and ispresent(v_groupItem.ordinalElements.vehicleTrailerAxlesNumber)) {
                        for (var integer v_idx := 0; v_idx < sizeof(p_locvehclass.ordinalElements.vehicleTrailerAxlesNumber); v_idx := v_idx + 1) {
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_groupItem.ordinalElements.vehicleTrailerAxlesNumber); v_jdx := v_jdx + 1) {
                                if (not ((v_groupItem.ordinalElements.vehicleTrailerAxlesNumber[v_jdx].lowerLimit < p_locvehclass.ordinalElements.vehicleTrailerAxlesNumber[v_idx].lowerLimit) or (v_groupItem.ordinalElements.vehicleTrailerAxlesNumber[v_jdx].upperLimit > p_locvehclass.ordinalElements.vehicleTrailerAxlesNumber[v_idx].upperLimit))) {
                                    // There is an overlapp
                                    return true;
                                }
                            }
                        }
                    }
                    // 6. vehicleMaxLadenWeight
                    if (ispresent(p_locvehclass.ordinalElements.vehicleMaxLadenWeight) and ispresent(v_groupItem.ordinalElements.vehicleMaxLadenWeight)) {
                        for (var integer v_idx := 0; v_idx < sizeof(p_locvehclass.ordinalElements.vehicleMaxLadenWeight); v_idx := v_idx + 1) {
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_groupItem.ordinalElements.vehicleMaxLadenWeight); v_jdx := v_jdx + 1) {
                                if (not ((v_groupItem.ordinalElements.vehicleMaxLadenWeight[v_jdx].lowerLimit < p_locvehclass.ordinalElements.vehicleMaxLadenWeight[v_idx].lowerLimit) or (v_groupItem.ordinalElements.vehicleMaxLadenWeight[v_jdx].upperLImit > p_locvehclass.ordinalElements.vehicleMaxLadenWeight[v_idx].upperLImit))) {
                                    // There is an overlapp
                                    return true;
                                }
                            }
                        }
                    }
                    // 7. vehicleTrainMaximumWeight
                    if (ispresent(p_locvehclass.ordinalElements.vehicleTrainMaximumWeight) and ispresent(v_groupItem.ordinalElements.vehicleTrainMaximumWeight)) {
                        for (var integer v_idx := 0; v_idx < sizeof(p_locvehclass.ordinalElements.vehicleTrainMaximumWeight); v_idx := v_idx + 1) {
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_groupItem.ordinalElements.vehicleTrainMaximumWeight); v_jdx := v_jdx + 1) {
                                if (not ((v_groupItem.ordinalElements.vehicleTrainMaximumWeight[v_jdx].lowerLimit < p_locvehclass.ordinalElements.vehicleTrainMaximumWeight[v_idx].lowerLimit) or (v_groupItem.ordinalElements.vehicleTrainMaximumWeight[v_jdx].upperLimit > p_locvehclass.ordinalElements.vehicleTrainMaximumWeight[v_idx].upperLimit))) {
                                    // There is an overlapp
                                    return true;
                                }
                            }
                        }
                    }
                    // 8. vehicleWeightUnladen
                    if (ispresent(p_locvehclass.ordinalElements.vehicleWeightUnladen) and ispresent(v_groupItem.ordinalElements.vehicleWeightUnladen)) {
                        for (var integer v_idx := 0; v_idx < sizeof(p_locvehclass.ordinalElements.vehicleWeightUnladen); v_idx := v_idx + 1) {
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_groupItem.ordinalElements.vehicleWeightUnladen); v_jdx := v_jdx + 1) {
                                if (not ((v_groupItem.ordinalElements.vehicleWeightUnladen[v_jdx].lowerLimit < p_locvehclass.ordinalElements.vehicleWeightUnladen[v_idx].lowerLimit) or (v_groupItem.ordinalElements.vehicleWeightUnladen[v_jdx].upperLimit > p_locvehclass.ordinalElements.vehicleWeightUnladen[v_idx].upperLimit))) {
                                    // There is an overlapp
                                    return true;
                                }
                            }
                        }
                    }
                    // 9. vehicleWeightLaden
                    if (ispresent(p_locvehclass.ordinalElements.vehicleWeightLaden) and ispresent(v_groupItem.ordinalElements.vehicleWeightLaden)) {
                        for (var integer v_idx := 0; v_idx < sizeof(p_locvehclass.ordinalElements.vehicleWeightLaden); v_idx := v_idx + 1) {
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_groupItem.ordinalElements.vehicleWeightLaden); v_jdx := v_jdx + 1) {
                                if (not ((v_groupItem.ordinalElements.vehicleWeightLaden[v_jdx].lowerLimit < p_locvehclass.ordinalElements.vehicleWeightLaden[v_idx].lowerLimit) or (v_groupItem.ordinalElements.vehicleWeightLaden[v_jdx].upperLimit > p_locvehclass.ordinalElements.vehicleWeightLaden[v_idx].upperLimit))) {
                                    // There is an overlapp
                                    return true;
                                }
                            }
                        }
                    }
                    // 10. euroValue
                    if (ispresent(p_locvehclass.ordinalElements.euroValue) and ispresent(v_groupItem.ordinalElements.euroValue)) {
                        for (var integer v_idx := 0; v_idx < sizeof(p_locvehclass.ordinalElements.euroValue); v_idx := v_idx + 1) {
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_groupItem.ordinalElements.euroValue); v_jdx := v_jdx + 1) {
                                if (not ((v_groupItem.ordinalElements.euroValue[v_jdx].lowerLimit < p_locvehclass.ordinalElements.euroValue[v_idx].lowerLimit) or (v_groupItem.ordinalElements.euroValue[v_jdx].upperLimit > p_locvehclass.ordinalElements.euroValue[v_idx].upperLimit))) {
                                    // There is an overlapp
                                    return true;
                                }
                            }
                        }
                    }
                    // 11. copValue
                    if (ispresent(p_locvehclass.ordinalElements.copValue) and ispresent(v_groupItem.ordinalElements.copValue)) {
                        for (var integer v_idx := 0; v_idx < sizeof(p_locvehclass.ordinalElements.copValue); v_idx := v_idx + 1) {
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_groupItem.ordinalElements.copValue); v_jdx := v_jdx + 1) {
                                if (not ((v_groupItem.ordinalElements.copValue[v_jdx].lowerLimit < p_locvehclass.ordinalElements.copValue[v_idx].lowerLimit) or (v_groupItem.ordinalElements.copValue[v_jdx].upperLimit > p_locvehclass.ordinalElements.copValue[v_idx].upperLimit))) {
                                    // There is an overlapp
                                    return true;
                                }
                            }
                        }
                    }
                    // 12. vehicleClass
                    if (ispresent(p_locvehclass.ordinalElements.vehicleClass) and ispresent(v_groupItem.ordinalElements.vehicleClass)) {
                        for (var integer v_idx := 0; v_idx < sizeof(p_locvehclass.ordinalElements.vehicleClass); v_idx := v_idx + 1) {
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_groupItem.ordinalElements.vehicleClass); v_jdx := v_jdx + 1) {
                                if (not ((v_groupItem.ordinalElements.vehicleClass[v_jdx].lowerLimit < p_locvehclass.ordinalElements.vehicleClass[v_idx].lowerLimit) or (v_groupItem.ordinalElements.vehicleClass[v_jdx].upperLimit > p_locvehclass.ordinalElements.vehicleClass[v_idx].upperLimit))) {
                                    // There is an overlapp
                                    return true;
                                }
                            }
                        }
                    }
                    // 13. CO2EmissionValueRange
                    if (ispresent(p_locvehclass.ordinalElements.co2EmissionValue) and ispresent(v_groupItem.ordinalElements.co2EmissionValue)) {
                        for (var integer v_idx := 0; v_idx < sizeof(p_locvehclass.ordinalElements.co2EmissionValue); v_idx := v_idx + 1) {
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_groupItem.ordinalElements.co2EmissionValue); v_jdx := v_jdx + 1) {
                                if (not ((v_groupItem.ordinalElements.co2EmissionValue[v_jdx].lowerLimit < p_locvehclass.ordinalElements.co2EmissionValue[v_idx].lowerLimit) or (v_groupItem.ordinalElements.co2EmissionValue[v_jdx].upperLimit > p_locvehclass.ordinalElements.co2EmissionValue[v_idx].upperLimit))) {
                                    // There is an overlapp
                                    return true;
                                }
                            }
                        }
                    }
                    // 14. DieselEmissionValueRange
                    if (ispresent(p_locvehclass.ordinalElements.dieselEmissionValue) and ispresent(v_groupItem.ordinalElements.dieselEmissionValue)) {
                        for (var integer v_idx := 0; v_idx < sizeof(p_locvehclass.ordinalElements.dieselEmissionValue); v_idx := v_idx + 1) {
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_groupItem.ordinalElements.dieselEmissionValue); v_jdx := v_jdx + 1) {
                                if (ispresent(v_groupItem.ordinalElements.dieselEmissionValue[v_jdx].particulate) and ispresent(p_locvehclass.ordinalElements.dieselEmissionValue[v_idx].particulate)) {
                                    if (match(v_groupItem.ordinalElements.dieselEmissionValue[v_jdx].particulate.unitType, p_locvehclass.ordinalElements.dieselEmissionValue[v_idx].particulate.unitType)) {
                                        if (not ((v_groupItem.ordinalElements.dieselEmissionValue[v_jdx].particulate.valueRange.lowerLimit < p_locvehclass.ordinalElements.dieselEmissionValue[v_idx].particulate.valueRange.lowerLimit) or (v_groupItem.ordinalElements.dieselEmissionValue[v_jdx].particulate.valueRange.upperLimit > p_locvehclass.ordinalElements.dieselEmissionValue[v_idx].particulate.valueRange.upperLimit))) {
                                            // There is an overlapp
                                            return true;
                                        }
                                    }
                                }
                                if (ispresent(v_groupItem.ordinalElements.dieselEmissionValue[v_jdx].absorptionCoeffRange) and ispresent(p_locvehclass.ordinalElements.dieselEmissionValue[v_idx].absorptionCoeffRange)) {
                                    if (not ((v_groupItem.ordinalElements.dieselEmissionValue[v_jdx].absorptionCoeffRange.lowerLimit < p_locvehclass.ordinalElements.dieselEmissionValue[v_idx].absorptionCoeffRange.lowerLimit) or (v_groupItem.ordinalElements.dieselEmissionValue[v_jdx].absorptionCoeffRange.upperLimit > p_locvehclass.ordinalElements.dieselEmissionValue[v_idx].absorptionCoeffRange.upperLimit))) {
                                        // There is an overlapp
                                        return true;
                                    }
                                }
                            }
                        }
                    }
                    // 15. ExhaustEmissionValueRange
                    if (ispresent(p_locvehclass.ordinalElements.exhaustEmissionValue) and ispresent(v_groupItem.ordinalElements.exhaustEmissionValue)) {
                        for (var integer v_idx := 0; v_idx < sizeof(p_locvehclass.ordinalElements.exhaustEmissionValue); v_idx := v_idx + 1) {
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_groupItem.ordinalElements.exhaustEmissionValue); v_jdx := v_jdx + 1) {
                                if (match(v_groupItem.ordinalElements.exhaustEmissionValue[v_jdx].unitType, p_locvehclass.ordinalElements.exhaustEmissionValue[v_idx].unitType)) {
                                    if (ispresent(v_groupItem.ordinalElements.exhaustEmissionValue[v_jdx].emissionCORange) and ispresent(p_locvehclass.ordinalElements.exhaustEmissionValue[v_idx].emissionCORange)) {
                                        if (not ((v_groupItem.ordinalElements.exhaustEmissionValue[v_jdx].emissionCORange.lowerLimit < p_locvehclass.ordinalElements.exhaustEmissionValue[v_idx].emissionCORange.lowerLimit) or (v_groupItem.ordinalElements.exhaustEmissionValue[v_jdx].emissionCORange.upperLimit > p_locvehclass.ordinalElements.exhaustEmissionValue[v_idx].emissionCORange.upperLimit))) {
                                            // There is an overlapp
                                            return true;
                                        }
                                    }
                                    if (ispresent(v_groupItem.ordinalElements.exhaustEmissionValue[v_jdx].emissionHCRange) and ispresent(p_locvehclass.ordinalElements.exhaustEmissionValue[v_idx].emissionHCRange)) {
                                        if (not ((v_groupItem.ordinalElements.exhaustEmissionValue[v_jdx].emissionHCRange.lowerLimit < p_locvehclass.ordinalElements.exhaustEmissionValue[v_idx].emissionHCRange.lowerLimit) or (v_groupItem.ordinalElements.exhaustEmissionValue[v_jdx].emissionHCRange.upperLimit > p_locvehclass.ordinalElements.exhaustEmissionValue[v_idx].emissionHCRange.upperLimit))) {
                                            // There is an overlapp
                                            return true;
                                        }
                                    }
                                }
                            } 
                        }
                    }
                }
                
            } // End of 'for' loop

            return false;
        } // End of function f_isItemInLocalVehicleClasseGroups

        /**
         * @desc    This function builds the overlapped groups based on at least one criterion
         * @param   p_timeclassList The list of the TimeClass values
         * @return  The built group
         * @verdict unchanged
         */
        function f_build_timeClass_groups(
                                          in TimeClassDefinition.timeClasses p_timeclassList
        ) runs on EutComp return TimeClassesGroups {
            var TimeClassesGroups v_groups := { }; // Group timeClasses that overlap at least with one criterion
            var boolean v_createNewGroup; // Used to indicate if a new group shall be created

            // Parse all TimeClass items in the list p_timeclassList
            for (var integer v_idx := 0; v_idx < sizeof(p_timeclassList); v_idx := v_idx + 1) {
                v_createNewGroup := true; // Default value
                // Parse each group
                for (var integer v_igroup := 0; v_igroup < sizeof(v_groups); v_igroup := v_igroup + 1) {
                    if (f_isItemInTimeClasseGroups(p_timeclassList[v_idx], v_groups[v_igroup])) {
                        // An ovelapp was found, add current TimeClass item into the current group...
                        v_groups[v_igroup][sizeof(v_groups[v_igroup])] := p_timeclassList[v_idx];
                        v_createNewGroup := false; // Creation is not required
                        break; // ...and exit from the loop
                    }
                } // End of 'for' statement
                if (v_createNewGroup == true) {
                    // Create a new group with the current TimeClass item
                    v_groups[sizeof(v_groups)] := { p_timeclassList[v_idx] };
                }
            } // End of 'for' statement

            return v_groups; // Error
        } // End of function f_build_timeClass_groups

        /**
         * @desc    This function searches for overlap based on one criterion
         * @param   p_timeclass The TimeClass item to process
         * @param   p_classInGroup The list of group timeClasses that overlap at least with one criterion
         * @return  true if p_timeclass value overlaps one of the TimeClass item in a group, false otherwise
         * @verdict unchanged
         */
        function f_isItemInTimeClasseGroups(
                                            in TimeClass p_timeclass, 
                                            in TimeClassGroupItem p_classInGroup
        ) runs on EutComp return boolean {

            for (var integer v_idxTimeClass := 0; v_idxTimeClass < sizeof(p_classInGroup); v_idxTimeClass := v_idxTimeClass + 1) {
                var TimeClass v_groupItem := p_classInGroup[v_idxTimeClass];
                // Check nominalElements

                // Check ordinalElements
                if (ispresent(p_timeclass.ordinalElements) and ispresent(v_groupItem.ordinalElements)) {
                    // 1. weekdays
                    if (ispresent(p_timeclass.ordinalElements[0].weekdays) and ispresent(v_groupItem.ordinalElements[0].weekdays)) {
                        for (var integer v_idx := 0; v_idx < sizeof(p_timeclass.ordinalElements[0].weekdays); v_idx := v_idx + 1) {
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_groupItem.ordinalElements[0].weekdays); v_jdx := v_jdx + 1) {
                                if (not ((v_groupItem.ordinalElements[0].weekdays[v_jdx].startDay < p_timeclass.ordinalElements[0].weekdays[v_idx].startDay) or (v_groupItem.ordinalElements[0].weekdays[v_jdx].endDay > p_timeclass.ordinalElements[0].weekdays[v_idx].endDay))) {
                                    // There is an overlapp
                                    return true;
                                }
                            } // End of 'for ' statement
                        } // End of 'for ' statement
                    }
                    // 2. absoluteTimeOfDay
                    if (ispresent(p_timeclass.ordinalElements[0].absoluteTimeOfDay) and ispresent(v_groupItem.ordinalElements[0].absoluteTimeOfDay)) {
                        for (var integer v_idx := 0; v_idx < sizeof(p_timeclass.ordinalElements[0].absoluteTimeOfDay); v_idx := v_idx + 1) {
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_groupItem.ordinalElements[0].absoluteTimeOfDay); v_jdx := v_jdx + 1) {
                                if (not (
                                (f_compareTime(v_groupItem.ordinalElements[0].absoluteTimeOfDay[v_jdx].startTime, p_timeclass.ordinalElements[0].absoluteTimeOfDay[v_idx].startTime) == -1) or 
                                (f_compareTime(v_groupItem.ordinalElements[0].absoluteTimeOfDay[v_jdx].endTime, p_timeclass.ordinalElements[0].absoluteTimeOfDay[v_idx].endTime) == 1))) {
                                    // There is an overlapp
                                    return true;
                                }
                            } // End of 'for ' statement
                        } // End of 'for ' statement
                    }
                    // 3. relativeTimePeriods
                    if (ispresent(p_timeclass.ordinalElements[0].relativeTimePeriods) and ispresent(v_groupItem.ordinalElements[0].relativeTimePeriods)) {
                        for (var integer v_idx := 0; v_idx < sizeof(p_timeclass.ordinalElements[0].relativeTimePeriods); v_idx := v_idx + 1) {
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_groupItem.ordinalElements[0].relativeTimePeriods); v_jdx := v_jdx + 1) {
                                if (not ((v_groupItem.ordinalElements[0].relativeTimePeriods[v_jdx].minPeriod < p_timeclass.ordinalElements[0].relativeTimePeriods[v_idx].minPeriod) or (v_groupItem.ordinalElements[0].relativeTimePeriods[v_jdx].maxPeriod > p_timeclass.ordinalElements[0].relativeTimePeriods[v_idx].maxPeriod))) {
                                    // There is an overlapp
                                    return true;
                                }
                            } // End of 'for ' statement
                        } // End of 'for ' statement
                    }
                    // 4. periodsInYear
                    if (ispresent(p_timeclass.ordinalElements[0].periodsInYear) and ispresent(v_groupItem.ordinalElements[0].periodsInYear)) {
                        for (var integer v_idx := 0; v_idx < sizeof(p_timeclass.ordinalElements[0].periodsInYear); v_idx := v_idx + 1) {
                            for (var integer v_jdx := 0; v_jdx < sizeof(v_groupItem.ordinalElements[0].periodsInYear); v_jdx := v_jdx + 1) {
                                if (not (f_compareDateCompact(v_groupItem.ordinalElements[0].periodsInYear[v_jdx].startDay, p_timeclass.ordinalElements[0].periodsInYear[v_idx].startDay) == -1) or (f_compareDateCompact(v_groupItem.ordinalElements[0].periodsInYear[v_jdx].endDay, p_timeclass.ordinalElements[0].periodsInYear[v_idx].endDay) == 1)) {
                                    // There is an overlapp
                                    return true;
                                }
                            } // End of 'for ' statement
                        } // End of 'for ' statement
                    }
                }
            } // End of 'for ' statement

            return false;
        } // End of function f_isItemInTimeClasseGroups

        /**
         * @desc    This function builds the overlapped groups based on at least one criterion
         * @param   p_userclassList The list of the UserClass values
         * @return  The built group
         * @verdict unchanged
         */
        function f_build_userClass_groups(
                                          in UserClassDefinition.userClasses p_userclassList
        ) runs on EutComp return UserClassesGroups {
            var UserClassesGroups v_groups := { }; // Group userlasses that overlap at least with one criterion
            var boolean v_createNewGroup; // Used to indicate if a new group shall be created

            // Parse all UserClass items in the list p_userclassList
            for (var integer v_idx := 0; v_idx < sizeof(p_userclassList); v_idx := v_idx + 1) {
                v_createNewGroup := true; // Default value
                // Parse each group
                for (var integer v_igroup := 0; v_igroup < sizeof(v_groups); v_igroup := v_igroup + 1) {
                    if (f_isItemInUserClasseGroups(p_userclassList[v_idx], v_groups[v_igroup])) {
                        // An ovelapp was found, add current TimeClass item into the current group...
                        v_groups[v_igroup][sizeof(v_groups[v_igroup])] := p_userclassList[v_idx];
                        v_createNewGroup := false; // Creation is not required
                        break; // ...and exit from the loop
                    }
                } // End of 'for' statement
                if (v_createNewGroup == true) {
                    // Create a new group with the current TimeClass item
                    v_groups[sizeof(v_groups)] := { p_userclassList[v_idx] };
                }
            } // End of 'for' statement

            return v_groups; // Error
        } // End of function f_build_userClass_groups

        /**
         * @desc    This function searches for user classes that have exactly the same values of following data elements: contractTypes and numberOfPassangers
         * @param   p_userclass The UserClass item to process
         * @param   p_classInGroup The list of group timeClasses that overlap at least with one criterion
         * @return  true if p_userclass value have exactly the same values than one of the UserClass item in a group, false otherwise
         * @verdict unchanged
         */
        function f_isItemInUserClasseGroups(
                                            in UserClass p_userclass, 
                                            in UserClassGroupItem p_classInGroup
        ) runs on EutComp return boolean {

            template UserClass m_select (in UserClass.contractTypes p_contractTypes, in UserClass.actualNumberOfPassengers p_actualNumberOfPassengers) := {
                userClassId := ?, // Ignored
                contractTypes := p_contractTypes, // Value to compare
                actualNumberOfPassengers := p_actualNumberOfPassengers, // Value to compare
                priorityValue := omit
            } // This template is used to check if p_userclass value matches one of group items

            for (var integer v_idxUserClass := 0; v_idxUserClass < sizeof(p_classInGroup); v_idxUserClass := v_idxUserClass + 1) {
                var UserClass v_groupItem := p_classInGroup[v_idxUserClass];
                // Check if data element are identicals
                if (match(valueof(v_groupItem), m_select(p_userclass.contractTypes, p_userclass.actualNumberOfPassengers))) {
                    return true;
                }
            } // End of 'for' statement

            return false;
        } // End of function f_isItemInUserClasseGroups

        /**
         * @desc    Verify that the provided point is pointIdentifier EX-OR pointCoordinates 
         * @return  true on success, false otherwise
         * @verdict unchanged
         */
        function f_check_point(
                               in Point p_point
        ) runs on EutComp return boolean {
            return ischosen(p_point.pointIdentifier);
        }

        /**
         * @desc    This function builds the list of the pointId declared in p_pointIDList
         * @param   p_networkPoints The NetworkPoint items to process
         * @return  true if p_userclass value have exactly the same values than one of the UserClass item in a group, false otherwise
         * @verdict unchanged
         */
        function f_build_pointId_sectionLayout_networkPoints(
                                                             in SectionLayout.networkPoints p_networkPoints
        ) runs on EutComp return charstring {
            var charstring v_pointIdFound := ";";

            for (var integer v_idx := 0; v_idx < sizeof(p_networkPoints); v_idx := v_idx + 1) {
                v_pointIdFound := v_pointIdFound & int2str(p_networkPoints[v_idx].pointId) & ";";
            } // End of 'for' statement
            
            return v_pointIdFound;
        } // End of function f_build_pointId_sectionLayout_networkPoints

        /**
         * @desc    This function builds the list of the pointId declared in p_pointIDList
         * @param   p_networkPoints The Point items to process
         * @return  true if p_userclass value have exactly the same values than one of the UserClass item in a group, false otherwise
         * @verdict unchanged
         */
        function f_build_PointId_RoadNetworkObject_NetworkPoints(
                                                                 in RoadNetworkObject.networkPoints p_networkPoints
        ) runs on EutComp return charstring {
            var charstring v_pointIdFound := ";";

            for (var integer v_idx := 0; v_idx < sizeof(p_networkPoints); v_idx := v_idx + 1) {
                if (ischosen(p_networkPoints[v_idx].pointIdentifier)) {
                    v_pointIdFound := v_pointIdFound & int2str(p_networkPoints[v_idx].pointIdentifier) & ";";
                }
            } // End of 'for' statement
            
            return v_pointIdFound;
        } // End of function f_build_PointId_RoadNetworkObject_NetworkPoints

        /**
         * @desc    This function builds the list of the timeId declared in p_timeclasses
         * @param   p_timeclasses The TimeClasses to process
         * @return  The Time Classe Id list
         * @verdict unchanged
         */
        function f_build_timeId_timeClasses(
                                            in TimeClassDefinition.timeClasses p_timeclasses
        ) runs on EutComp return charstring {
            var charstring v_timeClassIdFound := ";";

            for (var integer v_idx := 0; v_idx < sizeof(p_timeclasses); v_idx := v_idx + 1) {
                v_timeClassIdFound := v_timeClassIdFound & int2str(p_timeclasses[v_idx].timeClassId) & ";";
            } // End of 'for' statement
            
            return v_timeClassIdFound;
        } // End of function f_build_timeId_timeClasses

        /**
         * @desc    This function verifies the uniqueness of localVehivleClassId in LocalVehicleClassIds list
         * @param   p_locvehclassList localVehivleClassId list
         * @return  true on success, false otherwise
         * @verdict unchanged
         */
        function f_check_uniqueness_localVehicleClassId_1(
                                                          in TariffClass.localVehicleClasses p_localVehicleClassIds
        ) runs on EutComp return boolean {
            // p_localVehicleClassIds shall not be omit

            var charstring v_localVehicleClassIdFound := ";"; // Used to build the list of the localVehicleClassId already processed
            var charstring v_localVehicleClassId; // localVehicleClassId currently processed
            var template charstring m_found_pattern; // Used in regex to verify that 'localVehicleClassId' was not found before

            // Parse LocalVehicleClasses list
            for (var integer v_idx := 0; v_idx < sizeof(p_localVehicleClassIds); v_idx := v_idx + 1) {
                v_localVehicleClassId := int2str(p_localVehicleClassIds[v_idx]);
                m_found_pattern := pattern "*({v_localVehicleClassId})*";
                if (regexp(v_localVehicleClassIdFound, m_found_pattern, 0) == v_localVehicleClassId) {
                    return false; // localVehicleClassId exist at least 2 times, uniqueness is not verified
                }
                // localVehicleClassId non found, add current localVehicleClassId into the built list
                v_localVehicleClassIdFound := v_localVehicleClassIdFound & v_localVehicleClassId & ";";
            } // End of 'for' statement
            
            return true;
        } // End of function f_check_uniqueness_localVehicleClassId_1

        /**
         * @desc    This function verifies the uniqueness of timeClassId in TimeClassIds list
         * @param   p_timeclassList timeClassId list
         * @return  true on success, false otherwise
         * @verdict unchanged
         */
        function f_check_uniqueness_timeClassId_1(
                                                  in TariffClass.timeClasses p_timeClassIds
        ) runs on EutComp return boolean {
            // p_timeClassIds shall not be omit

            var charstring v_timeClassIdFound := ";"; // Used to build the list of the timeClassId already processed
            var charstring v_timeClassId; // timeClassId currently processed
            var template charstring m_found_pattern; // Used in regex to verify that 'timeClassId' was not found before

            // Parse TimeClass list
            for (var integer v_idx := 0; v_idx < sizeof(p_timeClassIds); v_idx := v_idx + 1) {
                v_timeClassId := int2str(p_timeClassIds[v_idx]);
                m_found_pattern := pattern "*({v_timeClassId})*";
                if (regexp(v_timeClassIdFound, m_found_pattern, 0) == v_timeClassId) {
                    return false; // timeClassId exist at least 2 times, uniqueness is not verified
                }
                // timeClassId non found, add current timeClassId into the built list
                v_timeClassIdFound := v_timeClassIdFound & v_timeClassId & ";";
            } // End of 'for' statement
            
            return true;
        } // End of function f_check_uniqueness_timeClassId_1

        /**
         * @desc    This function verifies the uniqueness of userClassId in UserClassIds list
         * @param   p_userclassList userClassId list
         * @return  true on success, false otherwise
         * @verdict unchanged
         */
        function f_check_uniqueness_userClassId_1(
                                                  in TariffClass.userClasses p_userClassIds
        ) runs on EutComp return boolean {
            // p_userClassIds shall not be omit

            var charstring v_userClassIdFound := ";"; // Used to build the list of the userClassId already processed
            var charstring v_userClassId; // userClassId currently processed
            var template charstring m_found_pattern; // Used in regex to verify that 'userClassId' was not found before

            // Parse TimeClass list
            for (var integer v_idx := 0; v_idx < sizeof(p_userClassIds); v_idx := v_idx + 1) {
                v_userClassId := int2str(p_userClassIds[v_idx]);
                m_found_pattern := pattern "*({v_userClassId})*";
                if (regexp(v_userClassIdFound, m_found_pattern, 0) == v_userClassId) {
                    return false; // userClassId exist at least 2 times, uniqueness is not verified
                }
                // userClassId non found, add current userClassId into the built list
                v_userClassIdFound := v_userClassIdFound & v_userClassId & ";";
            } // End of 'for' statement
            
            return false; // Error
        } // End of function f_check_uniqueness_userClassId

        /**
         * @desc    This function verifies the uniqueness of locationClassId in LocationClassId list
         * @param   p_locationClasses locationClassId list
         * @return  true on success, false otherwise
         * @verdict unchanged
         */
        function f_check_uniqueness_locationClassId_1(
                                                      in TariffClass.locationClasses p_locationClassIds
        ) runs on EutComp return boolean {
            // p_locationClassIds shall not be omit

            var charstring v_locationClassIdFound := ";"; // Used to build the list of the locationClassId already processed
            var charstring v_locationClassId; // locationClassId currently processed
            var template charstring m_found_pattern; // Used in regex to verify that 'locationClassId' was not found before

            // Parse LocationClasses list
            for (var integer v_idx := 0; v_idx < sizeof(p_locationClassIds); v_idx := v_idx + 1) {
                v_locationClassId := int2str(p_locationClassIds[v_idx]);
                m_found_pattern := pattern "*({v_locationClassId})*";
                if (regexp(v_locationClassIdFound, m_found_pattern, 0) == v_locationClassId) {
                    return false; // locationClassId exist at least 2 times, uniqueness is not verified
                }
                // locationClassId non found, add current locationClassId into the built list
                v_locationClassIdFound := v_locationClassIdFound & v_locationClassId & ";";
            } // End of 'for' statement
            
            return true;
        } // End of function f_check_uniqueness_locationClassId_1
        
//        /**
//         * @desc    This function sends Iso17575_3Adu message according to the security mode
//         * @param   p_Iso17575_3Adu Iso17575_3Adu message to be sent
//         * @verdict unchanged
//         */
//        function f_pco_send_iso17575_3Adu(
//                                          in template (value) Iso17575_3Adu p_Iso17575_3Adu
//        ) runs on EutComp {
//            if (not (PICS_SECURED_MODE)) {
//                pco.send(m_iso17575_3InformationContent_unsecured(p_Iso17575_3Adu));
//            } else {
//                var template (value) AuthenticatedIso17575_3Adu v_secured_packet;
//                f_secured_packet(p_Iso17575_3Adu, v_secured_packet);
//                pco.send(m_iso17575_3InformationContent_secured(v_secured_packet));
//            }
//        } // End of function f_pco_send_iso17575_3Adu
//        
//        altstep a_pco_recv_iso17575_3Adu_chargeReport(
//                                                      template ChargeReport p_chargeReportValueExpected,
//                                                      out template (value) ChargeReport p_chargeReportValue,
//                                                      out template (value) boolean p_result
//        ) runs on EutComp {
//            var AuthenticatedChargeReport v_authenticatedChargeReport;
//            
//            [PICS_SECURED_MODE == false] pco.receive(p_chargeReportValueExpected) -> value p_chargeReportValue {
//                p_result := true;
//            }
//            [PICS_SECURED_MODE == true] pco.receive(AuthenticatedChargeReport:?) -> value v_authenticatedChargeReport {
//                if (f_extract_ChargeReport(v_authenticatedChargeReport, p_chargeReportValue) == true) {
//                    p_result := match(p_chargeReportValueExpected, p_chargeReportValue);
//                } else {
//                    p_result := false;
//                }
//            }
//            [] pco.receive {
//                p_result := false;
//            }
//        } // End of function a_pco_recv_iso17575_3Adu_chargeReport
//        
//        altstep a_pco_recv_iso17575_3Adu(
//                                         template Iso17575_3Adu p_iso17575_3AduValueExpected,
//                                         out template (value) Iso17575_3Adu p_iso17575_3AduValue,
//                                         out template (value) boolean p_result
//        ) runs on EutComp {
//            var Iso17575_3InformationContent v_iso17575_3InformationContent;
//            
//            [PICS_SECURED_MODE == false] pco.receive(mw_iso17575_3InformationContent_unsecured(p_iso17575_3AduValueExpected)) -> value v_iso17575_3InformationContent {
//                p_iso17575_3AduValue := v_iso17575_3InformationContent.notAuthenticatedIso17575_3Adu;
//                p_result := true;
//            }
//            [PICS_SECURED_MODE == true] pco.receive(Iso17575_3InformationContent:?) -> value v_iso17575_3InformationContent {
//                if (f_extract_Iso17575(v_iso17575_3InformationContent.authenticatedIso1575_3Adu, p_iso17575_3AduValue) == true) {
//                    p_result := match(p_iso17575_3AduValueExpected, p_iso17575_3AduValue);
//                } else {
//                    p_result := false;
//                }
//            }
//            [] pco.receive {
//                p_result := false;
//            }
//        } // End of function a_pco_recv_iso17575_3Adu
//        
    } // End of group Internal_functions

    /**
     * @desc    UpperTester group
     */
    group DUT_Actions {
        /**
         * @desc    Defines UpperTester commands
         */
        group Arguments {
            /**
             * @desc    Event defined in ContextData1 occurred
             */
            const ParameterList raiseContext1Event := {
                "raiseEvent", "Context1",
                "", ""
            };
            /**
             * @desc    At least one UsageStatement can be reported by Front End and Event defined in ContextData9 occurred
             */
            const ParameterList raiseContext9Event := {
                "raiseEvent", "Context9",
                "", ""
            };
            /**
             * @desc    At least one UsageStatement for ContextData11 can be reported by Front End and Event defined in ContextData11 occurred
             */
            const ParameterList raiseContext11Event := {
                "raiseEvent", "Context11",
                "", ""
            };
            /**
             * @desc    Event defined in ContextData12 occurred
             */
            const ParameterList raiseContext12Event := {
                "raiseEvent", "Context12",
                "", ""
            };
            /**
             * @desc    Request the DUT to send an Iso1117575Adu message
             */
            const ParameterList raiseContext20Partition1AndPartition2Event := {
                "TollContextOverview.context20Partition1AndPartition2", "",
                "", ""
            };
            /**
             * @desc    Request the DUT to send an Iso1117575Adu message
             */
            const ParameterList raiseContext21Partition1AndPartition2Event := {
                "TollContextOverview.raiseContext21Partition1AndPartition2Event", "",
                "", ""
            };
            /**
             * @desc    Front End enters a toll context partition area
             */
            const ParameterList raiseEntersTollContextPartitionAreaEvent := {
                "raiseEntersTollContextPartitionAreaEvent", "Context1",
                "", ""
            };
            /**
             * @desc    Event defined in '41'D  ChargeReportingEvents occurred
             */
            const ParameterList raiseChargeReportingEvents := {
                "raiseChargeReportingEvents", "",
                "", ""
            };
            /**
             * @desc    Event defined in ContextData22 occurred
             */
            const ParameterList raiseContext22Event := {
                "raiseEvent", "Context22",
                "", ""
            };
            /**
             * @desc    Event defined in ContextData23 occurred
             */
            const ParameterList raiseContext23Event := {
                "raiseEvent", "Context23",
                "", ""
            };
            /**
             * @desc    Event defined in ContextData24 occurred
             */
            const ParameterList raiseContext24Event := {
                "raiseEvent", "Context24",
                "", ""
            };
            /**
             * @desc    Event defined in ContextData25 occurred
             */
            const ParameterList raiseContext25Event := {
                "raiseEvent", "Context25",
                "", ""
            };
            /**
             * @desc    Request the DUT to send an Iso1117575Adu message
             */
            const ParameterList raiseADU := {
                "raiseADU", "",
                "", ""
            };
            /**
             * @desc    Request the DUT to send an Iso1117575Adu message
             */
            const ParameterList raiseADUs_TollContext := {
                "raiseADUs_TollContext", "",
                "", ""
            };
            /**
             * @desc    Request the DUT to send several Iso1117575Adu messages
             */
            const ParameterList raiseADUs := {
                "raiseADUs", "",
                "", ""
            };
            /**
             * @desc    Request the DUT to send an Iso1117575Adu message
             */
            const ParameterList incTollRegime := {
                "TollContextOverview.tollRegime", "+10",
                "", ""
            };
        } // End of group Arguments
    } // End of group DUT_Actions
} // End of module ContextData_Functions